% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{bibnames}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{xcolor}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\newcommand{\originatorstate}{S_O}
\newcommand{\relayastate}{S_1}
\newcommand{\relaybstate}{S_2}
\newcommand{\refstate}{S_R}
\newcommand{\originatorsuccbal}{B^s_O}
\newcommand{\relayasuccbal}{B^s_1}
\newcommand{\relaybsuccbal}{B^s_2}
\newcommand{\originatorpredbal}{B^p_O}
\newcommand{\relayapredbal}{B^p_1}
\newcommand{\relaybpredbal}{B^p_2}
\newcommand{\nolift}{\emph{NO\_LIFT}}
\newcommand{\pend}{\emph{PEND}}
\newcommand{\call}{\emph{CALL}}
\newcommand{\void}{\emph{VOID}}
\newcommand{\good}{\emph{GOOD}}
\newcommand{\always}{\emph{always}}
\newcommand{\eventually}{\emph{eventually}}
\newcommand{\send}{\emph{Send}}
\newcommand{\receive}{\emph{Receive}}
\newcommand{\sendref}{\emph{SendRef}}
\newcommand{\receiveref}{\emph{ReceiveRef}}
\newcommand{\fair}{$F$}
\newcommand{\action}{\mathds{A}}
\newcommand{\listaction}{[\action]}
\newcommand{\promise}{\emph{promise}}
\newcommand{\commit}{\emph{commit}}
\newcommand{\happensbefore}{\prec_A}
\newcommand{\actsvalid}[2]{\mathds{V}(#1, #2)}
\newcommand{\projectsize}[2]{\mathds{P}(#1, #2)}
\newcommand{\basesystem}{\emph{base\_system}}
\newcommand{\inputset}[1]{\mathds{I}(#1)}
\newcommand{\outputset}[2]{\mathds{O}(#1, #2)}
\newcommand{\tracestruc}[1]{\mathds{T}(#1)}

\newcommand{\hra}[2]{\emph{has\_required\_actions}(#1, #2)}
\newcommand{\hndr}[1]{\emph{has\_no\_duplicate\_receives}(#1)}
\newcommand{\allrc}[2]{\emph{all\_receives\_causal}(#1, #2)}
\newcommand{\allst}[1]{\emph{all\_sends\_triggered}(#1)}
\newcommand{\allir}[2]{\emph{all\_ids\_in\_range}(#1, #2)}
\newcommand{\pfcb}[1]{\emph{promise\_forward\_commit\_backward}(#1)}
\newcommand{\psc}[1]{\emph{phase\_sequence\_correct}(#1)}
\newcommand{\allrrc}[1]{\emph{all\_ref\_receives\_causal}(#1)}

\newcommand{\coderepository}{Github repository at \url{https://github.com/byu-vv-lab/credit-lift-protocol-verification}}

\newif\ifcomments
\commentstrue
\newcommand{\egm}[1]{\ifcomments\textcolor{orange}{egm: #1}\fi}
\newcommand{\krs}[1]{\ifcomments\textcolor{blue}{krs: #1}\fi}


\begin{document}

\title{Extending Model Checking using Inductive Proofs in Distributed Digital Currency Protocols}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Kyle Storey \and Eric Mercer\orcidID{0000-0002-2264-2958}}
\institute{{Brigham Young University, Provo UT 84602, USA}
\email{kyle.r.storey@gmail.com,egm@cs.byu.edu}}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

Model checking is an effective method to verify both safety and liveness properties in distributed systems. However, the complexity of model checking grows exponentially with the number of entities which makes it suitable only for small systems.
Interactive theorem provers allow for machine-verified proofs. These proofs can include inductive reasoning which allows them to reason about an arbitrarily large number of entities. However, proving safety and liveness properties in these proofs can be difficult.
This work explores how combining model checking and inductive proofs can be an effective method for formally verifying complex distributed protocols. This is demonstrated on a part of MyCHIPs, a novel digital currency based on the value of personal credit \cite{bateman_myCHIPs}. It has been selected as a case study because it requires certain properties to hold on a non-trivial distributed algorithm. 

%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Model checking, interactive theorem provers, formal verification, distributed systems, digital currency}

\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}
%\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}



%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\section{Introduction}
\label{chap:introduction}
This work combines model checking with interactive theorem provers to verify safety and liveness properties in arbitrarily large distributed systems.
It uses a \emph{white box} approach for the model checking, which utilizes information about the internal state of each entity to verify certain properties hold.
It uses a \emph{black box} approach in the theorem prover, where only the inputs and outputs of each entity are considered.
If the set of observed inputs and outputs of each entity is unchanged as the system grows larger, then the set of internal states of each entity is unchanged.
When the set of inputs and outputs remains unchanged we say that the larger system \emph{conforms} to the smaller system \cite{dill_trace_theory}. This implies that the safety and liveness properties verified in the model checker continue to hold as the system grows large.

This process is demonstrated in a case study of MyCHIPs. MyCHIPs employs a distributed protocol as a means of facilitating the trade of goods and services between trusting partners. There are many temporal properties that must hold for MyCHIPs to meet its security and functionality requirements. This work verifies several of those properties.

In particular, this work verifies a distributed algorithm in the MyCHIPs system called a \emph{credit lift}. A \emph{credit lift} (\emph{lift} for brevity) in the MyCHIPs protocol operates on a group of agents arranged in a cycle such that each agent is in debt to its successor in the cycle. The protocol arranges for each to forgive their predecessor's debt, and in exchange, their own debt is forgiven. This protocol is critical for the MyCHIPs system to work correctly as a digital currency. Details of how this protocol fits in the larger system can be found in the appendix \ref{apdx:mychips}.

The debt clearing is done in two stages. First, each entity \emph{promises} to send CHIPs to their predecessor. Then, once all have promised, each entity \emph{commits} and sends CHIPs as promised. Once all have sent CHIPs, each entity's \emph{balance}--the difference between the number of sent CHIPs and the number of received CHIPs--remains the same, but they have cleared their liabilities. 

Unfortunately, sometimes entities on the MyCHIPs network may lose connectivity or otherwise become \emph{inactive}. An inactive node may not send or receive messages for an unbounded amount of time. It is not acceptable for lifts to hang in an unfinished state indefinitely. To prevent this, each lift is given a time limit, represented by a timestamp at which time the lift can no longer be committed. Because we don't expect entities on the network to have synchronized clocks, a referee is appointed whose clock is considered authoritative and acts as a consensus object. If the originator requests to commit before the timeout, the referee provides a digital signature that is proof that the lift has been committed. If the lift is not committed before the timeout, the lift becomes \emph{nullified} and the referee will digitally sign a statement that the lift has been nullified.

\subsection{Required Properties for MyCHIPs Correctness}\label{sec:requiredProperties}

MyCHIPS claims certain properties hold for its lift protocol but makes no formal arguments to prove those claims. This work formally proves some of those properties. These properties must hold for all compliant nodes on the network and must hold regardless of the number of nodes that participate in a lift. 

The properties this work will verify are as follows:

\begin{enumerate}
\item Lifts always eventually are committed or nullified for every active node. 
\item At the final state of the lift, every active node agrees that the lift was committed or every active node agrees the lift was nullified. 
\item The balance of every active node on the final state of the lift is equal to or greater than its initial balance.
\item Every active pair of nodes on the final state of the lift agree on their shared tally.
\end{enumerate}

Using a model checker, this work proves these properties hold in a system with just one originator---the node that initates the lift algorithm---one referee, and two relay nodes---nodes that participate in the lift that are not the originator or a referee. This work also defines a set of rules about a trace of events based on the constraints of the protocol. These rules can be used to determine if a trace of events is allowed by the protocol for a system of a given size. 
Then in the proof assistant Coq, we define the set of traces of events that are allowed by these rules. This is designed to enumerate the same set of traces checked by our model checker. This set of traces acts as an expression context as described by Dill \cite{dill_trace_theory} to define a conformation relation. If one subsystem conforms to another, it can be substituted without affecting the rest of the system's behavior. 
Using the model checking results as a base case, we prove that the set of traces produced by a chain of $n+1$ relay nodes conforms to the set of traces produced by $n$ relay nodes and inductively argue that the properties verified by model checking hold for any number of nodes.

\section{MyCHIPs protocol}
This section formally defines the MyCHIPs protocol, identifies the critical processes that require verification, and introduces the methods used to verify those processes.

\subsection{Credit Lift Algorithm}\label{sec:liftAlgorithm}
The MyCHIPs credit lift protocol described in Appendix \ref{apdx:coq_detail}, consists of three phases: discovery, promise, and commit. In the discovery phase, a circuit is identified where each entity is willing to participate in a lift. The correctness of the discovery phase is not critical because no transfer of value occurs during this phase. As such, this phase will not be verified.
Fig. \ref{fig:liftSequence} describes an example of a sequence of messages that would be passed in a typical lift during the promise and commit phases.

The originator initiates the lift by sending Relay 1 a lift record
$r = \langle id, value, ref, timeout\rangle.$ This record has a unique identifier, the lift value, the network ID of a referee that the originator selects, and a timeout timestamp. Sending this lift record represents a \promise and once Relay 1 obtains the referee's signature they can immediately add the number of chips specified in the lift record to its tally with the originator.

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{SequenceDiagramLifeline.png}
    \caption{Lift Protocol Sequence Example}
    \label{fig:liftSequence}
\end{figure}

When Relay 1 receives the lift record, it first confirms that it trusts the referee to be fair and available, and it confirms that the timeout timestamp is acceptable. If the referee is not trusted, or the known route to the target is no longer valid (for instance if it was used in a different lift and the node no longer has debt on that route to clear) it may choose to not continue. The node can optionally return a message indicating that it does not intend to complete the lift, or the node can simply ignore the message and wait for the lift to timeout. In the model used for verification, nodes ignore messages if they do not intend to participate in a lift. In our example, Relay 1 wishes to participate, so it forwards the lift record along with its own promise to Relay 2. Relay 2 then similarly evaluates the lift and decides to forward a promise to its predecessor which happens to be the originator. 

When the originator receives the promise from Relay 2, the lift moves into the commit phase and the originator sends the lift record to the referee to request a signature to commit. 

When the referee receives a lift record with a request to commit, it checks its clock to see if it received the commit message before the timeout. If it received the commit message after timeout, the Referee signs a statement nullifying the lift. If it received the commit message before the timeout, the referee signs the lift record and returns its signature to the originator. In either case, it records its result to provide to any node that requests the status of the lift. In the sequence diagram in Fig. \ref{fig:liftSequence}, the referee decides the commit message was received in time and sends the originator its signature.

When the originator receives the signature, it sends it to its successor in the circuit (Relay 2). Whenever a node in the circuit receives the signature, immediately the CHIPs it promised to its successor are valid. (i.e. it has forgiven the debt of its successor). 
To recover this value, it sends the signature to its predecessor.

In the sequence shown in Fig. \ref{fig:liftSequence}, once Relay 2 receives the signature, it experiences a long delay. Because of this delay, Relay 1 determines the lift is taking longer than expected and sends a message to the Referee to check the status of the lift. When the referee receives the status request, it checks its records and recalls the signature it previously provided to the originator. Because the lift is committed, the referee provides this signature to Relay 1. When a node receives a signature from the Referee instead of its predecessor it should not forward this signature. This ensures there is exactly one failure point in the cycle after which every node must obtain the lift status from the referee. This property is useful in proving the correctness of the protocol. However, eventually, Relay 1 receives the signature from Relay 2 which allows it to forward the signature. If the message sent by Relay 2 had arrived sooner, Relay 1 would not have needed to request the status from the Referee. Once the originator receives the signature from Relay 1, all nodes have received exactly the amount of CHIPs they have given and the lift is complete.

Note that the protocol makes a distinction between three roles nodes can take: originator, referee, or relay. In every lift, there is always exactly one originator, and exactly one referee, and there can be any number of relay nodes. These roles determine the types of actions a node can take and therefore define distinct equivalence classes to consider. 

\begin{figure}
    \centering
    \includegraphics[scale=0.42]{LiftStatesSeperate.png}
    \caption{Lift States Diagram}
    \label{fig:liftStates}
\end{figure}

Fig. \ref{fig:liftStates} describes the behavior expected from each of these equivalence classes as mealy machines.
These mealy machines are based on the state machines Bateman provides to define the protocol. \cite{bateman_state_machines} 
In the figure, each box represents the state of the lift from the perspective of the node, and each arrow represents a change in state and an associated action that is taken during the transition from one state to the next. Each transition is labeled with a condition that must be true for the transition to be taken, separated by a $/$ from an action that is taken during the transition. Each node has stored: the network ID of its predecessor (Pred), its successor (Succ), and the Referee. A transition can be made conditional on receiving a particular message from a particular network ID. This case is written in the form \emph{sender} $?$ \emph{message\_type}. As an action during a transition, nodes may transmit a particular message to a particular network ID. This case is written in the form \emph{recipient} $!$ \emph{message\_type}. 

The Spin model used as the model checking system is based on the mealy machine in Fig. \ref{fig:liftStates}. The details of that implementation are described in Section \ref{chap:model_checking_results}. The set of rules for the proof in Coq are defined based on the mealy machine in Fig. \ref{fig:liftStates} and the sequence diagram in 
 Fig. \ref{fig:liftSequence}. Details of that implementation are described in Section \ref{chap:coq_results}.
 
\section{Extending model-checking results using an inductive proof}
\label{sec:extending}

\egm{Great first draft. State the result as a theorem in a theorem environment. State each condition as either lemmas or theorems. and not a condition. These are admitted without any explanation beyond what they mean. Also, state condition 2 in terms of conformance. Be sure to define the base system very clearly. Push detailed items relative to conformance to the Coq model section since it needs a strong tie to conformance. Here just define it's meaning intuitively. So this sections should state the theorems/lemmas, and then manually prove that top-level theorem. I would expect an actual manual proof ending with QED. It should not be too hard since you have the lemmas/theorems that you need already admitted. For conditions (2) relative to the blackbox verification, make it its own section with the best argument you can and push the rest to future work.}

\egm{The subsequent sections, one for each lemma/theorem to support the top level proof need new opening paragraphs. These new openings reframe the text in the context of the stated lemma used in the top-level proof. For example, the model checking section is now defined around the base system and cites proof by exhaustive search as the proof mechanism of the theorem/lemma. That leads to a brief explanation of SPIN/LTL, and then you can transition to the existing text. The same would happen for the other sections. Doest that make sense?}
\krs{I think it makes sense, I've got this all done. I'm thinking it may make sense to restate each lemma in their relevant section and prove they are true in a proof environment. I would use some informal methods like "By exhaustive search." But before I put the lipstick on I'd like to be sure its not a pig. Is it a pig? Does the logic check out for those sections? Does the Theorem 1 logic check out?}

To prove that certain properties hold for an arbitrarily large system, we can use trace theory as described by Dill. Trace theory considers when it is safe to substitute one module for another. Dill defines conformance: a reflexive and transitive relation with the property that if $T' \preceq T$ then the module that produces the trace structure $T'$ can be safely substituted for the module that produces the trace structure $T$ \cite{dill_trace_theory}.

We can use the conformance relation to prove that a set of properties hold on an arbitrarily large system. To do so we utilize the following four lemmas. 

\begin{lemma}[The properties hold on the base system]
\label{lemma:base_system}
The properties hold for each node in a base system consisting of 1 originator, 2 relay nodes, and 1 referee.
$$\forall N, N \in \basesystem \longrightarrow P(\tracestruc{N})$$
Where $N$ is a node as implemented in the model-checker. And $P(\tracestruc{N})$ is a predicate over the state of N based on a set of traces that N observes.
\end{lemma}
\begin{lemma}[n nodes conform to 1 node]
\label{lemma:chain_conform}
A chain of n relay nodes conforms to a single relay node for nodes as implemented in the inductive proof.
$$\forall n \in \mathds{N}, \tracestruc{[N_0, N_1, ... N_n]} \preceq \tracestruc{N_0}
$$
Where $\tracestruc{N_0}$ denotes the trace structure generated by the node $N_0$ and $\preceq$ denotes the conformation relation described by Dill.
\end{lemma}

\begin{lemma}[proof nodes conform to model-checker nodes]
\label{lemma:ind_cof_model}
A node as implemented in the inductive proof conforms to a node as implemented in the model-checker.
$$\tracestruc{N_i} \preceq \tracestruc{N_m}$$
Where $N_i$ denotes a node as implemented in the inductive proof and $N_m$ denotes a node as implemented in the model-checker.
\end{lemma}
\egm{I'm not sure I understand what this condition means (the text in the following paragraphs didn't help entirely either).}
\krs{This is the brain blast. We can use conformance both to show a large system works the same as a small system as well as to make sure the system defined in the inductive proof works the same as the system defined in the model checker}

\begin{lemma}[All nodes in a large system are equivilant to some node in the base system]
\label{lemma:all_nodes_covered}
For any system of arbitrary size, we can construct the system such that the trace structure of any arbitrarily selected node is equivalent to a node in the base system.
$$
\forall N \in S, \exists N' \in \basesystem, \tracestruc{N'} = \tracestruc{N}.
$$
Where $S$ is a system of arbitrary size that was constructed by replacing nodes from the $\basesystem$. 
\end{lemma}


\begin{theorem}[The properties hold on an arbitrarily large system]
The desired properties hold for an arbitrarily large number of nodes utilizing the MyCHIPs protocol.
\begin{proof}\
\\
Consider the base system consisting of 1 originator, 2 relay nodes, and a referee, as implemented in the model checker. \\
Replace the first relay node in the base system ($N_1) $ with a relay node as defined in the inductive proof ($N_i$). \\
By Lemma \ref{lemma:ind_cof_model}, we know $N_i \preceq N_1$. \\
By trace theory, we know that the behavior of all other nodes is unchanged. \\
Now replace $N_i$ with a chain of nodes of arbitrary length. \\
By Lemma \ref{lemma:chain_conform}, and trace theory we know we know that the behavior of all other nodes is unchanged. \\
The constructed system is of arbitrary size. \\
By Lemma \ref{lemma:all_nodes_covered} we know the trace structure of any particular node can be mapped to some node in the $\basesystem$.  \\
Because of this mapping, by Lemma \ref{lemma:base_system}, we now know that the properties hold for any arbitrary node in the constructed system. \\
$$\tracestruc{N} = \tracestruc{N'} \wedge P(\tracestruc{N'}) \longrightarrow P(\tracestruc{N})$$
$\therefore$ The desired properties hold for an arbitrarily large number of nodes utilizing the MyCHIPs protocol.
\qed
\end{proof}
\end{theorem}

The intuition behind this method can be described by considering a black box that is inserted into the cycle. This is visualized in Fig. \ref{fig:coqExtension}. In the black box, there could be a single node or there could be a chain of N nodes. If we can show that the black box \emph{conforms} to a single node---i.e. the rest of the system cannot tell how many nodes are in the black box---we know that inserting the black box will not affect the behavior of the rest of the system. This means that the properties hold for any node that was not replaced by a black box. By carefully selecting which nodes we replace with black boxes we can construct a system such that any arbitrary node remains unchanged. This allows us to prove that the properties hold for all nodes in an arbitrarily large system. 

\egm{Shouldn't it be subseteq and superseteq? Strict subset/superset is stronger than what is needed. Right? Also, there needs to be a better transition to the next paragraph. It's not clear how it connects to the current paragraph.}
\krs{Yep you are right. But all that got moved into later sections now}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.35]{paper/CoqExtensionMethod.png}
    \caption{Method for extending model checking result}
    \label{fig:coqExtension}
\end{figure}

\subsubsection{Organization}
The remainder of this paper is organized as follows: Section \ref{chap:model_checking_results} describes how the first lemma was verified using model checking. Section \ref{chap:coq_results} describes how the second lemma is verified using an inductive proof generated in an interactive theorem prover. Section \ref{sec:inputs_map} argues that the third lemma holds for the model checking and inductive proof implementations. Finally, Section \ref{sec:nodes_map_base} proves the fourth lemma.

\section{Model Checking} \label{chap:model_checking_results}
We would like to prove that the properties hold on a base system consisting of 1 originator, 2 relay nodes, and a referee. The safety and liveness properties required for the MyCHIPs lift protocol can be proven by an exhaustive search all possible states in a small system. Spin is a powerful model-checking tool that allows for these types of properties to be expressed and verified. The state required by the system can be split into two classes: the part of the state that is evaluated when checking the properties, and the state that is used only to determine which state transition to take. We provide a formal definition of the former and a description of the latter. The source code for the complete spin model can be found on the \coderepository.
\subsection{Definition of the system state}\label{sec:statedef}
The system state is a combination of the individual states for each node. The state for the originator and each relay node can be represented as:
$$Node~state \equiv \langle S, B^s, B^p \rangle$$
$$
S \in \{\nolift, \pend, \call, \void, \good\}
$$
$$
B^s, B^p \in \mathds{Z}
$$
Here $S$ represents the mealy machine state and $B^s$ and $B^p$ represent the change in balance with the node's successor or predecessor respectively.

The state of the referee is similar except that it omits the balances
$$Referee~state \equiv \langle S \rangle$$

These are then composed together as a system state:
$$System~state \equiv \langle S_O, S_1, S_2, S_R, B^s_O, B^p_O, B^s_1, B^p_1, B^s_2, B^p_2  \rangle$$

With the $O$ subscript representing the \emph{originator}, $1$ and $2$ representing the first and second \emph{relay} nodes, and $R$ representing the \emph{referee}.

\subsection{Definition of the properties}
The desired properties are defined in terms of the simplified state presented in section \ref{sec:statedef}. 
The properties verified in the Spin model include a fairness property, and each of the properties described in section \ref{sec:requiredProperties}. 

\subsubsection{Linear-time temporal logic}
Linear-time temporal logic (LTL) allows for liveness properties to be defined. There are two temporal operators defined in LTL that are used to define the properties: \emph{always} and \emph{eventually}

The \emph{always} operator defines a property that holds only if the associated predicate is true for every possible system state.

The \emph{eventually} operator defines a property that holds if for all paths through the system state space there exists a state where the associated predicate is true. If there exists a path where the predicate is never true the property does not hold. That single path may be a path to a termination state, or it could just be a cycle of states. 

The composition \emph{always eventually} is used to make claims about the final state of the system. Using the \emph{eventually} construct alone will accept a trace where a predicate holds for a moment but doesn't hold later in the trace. Using \emph{always eventually} ensures that the predicate is true at all termination states of the system or any loop of non-termination states. 

\begin{definition}[A fairness property]
\begin{multline*}
    F \equiv \eventually \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}
\end{definition}
A fairness property is required as a consequence for not explicitly modeling time as described in section \ref{sec:model_time}. The referee must decide if a lift should be committed or nullified based on a timeout. When a node requests the status of a lift the referee may return a \good\ or \void\ message or they may send a \pend\ message if the timeout has not been reached yet and the lift is not yet committed. However, because this decision is modeled as a non-deterministic choice, the model considers the possibility that the referee will always send a pend message in an endless loop. Spin identifies this case and provides it as a counter-example for many of the properties. However, no matter how far into the future the timeout was set, eventually, the timeout will expire. So that counter-example is infeasible.

To tell Spin this is a case we are not interested in we define a fairness property that says that eventually the Referee is either in the \good\ or the \void\ state. However, when introducing a fairness constraint it is important to verify that that constraint can be met. If that constraint can not be met the properties will be \emph{vaccuously true}. Because of this, we need to add a new property to verify that the constraint is met in at least 1 case---and likely almost all cases. This would normally take the form of an existential property. Unfortunately, Spin does not perform well to prove existentials so instead we create a property that says that it is never true that the fairness property is met. We expect this property to fail. If it does it means that there are cases where the fairness property holds.

Once the fairness property is defined, we write all our properties in the form $F \longrightarrow property.$ This effectively trims out that infeasible case and allows Spin to continue and verify the remaining properties. 

\begin{definition}[Property 1]
\begin{multline*}
    P_1 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorstate = \good \vee \originatorstate = \void) \wedge \\
     (\relayastate = \good \vee \relayastate = \void) \wedge \\
     (\relaybstate = \good \vee \relaybstate = \void) \wedge \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}
\end{definition}
The purpose of $P_1$ is to verify that nodes are not left with a lift in an incomplete state forever. 
When a lift at a node is committed it moves the lift into the \good\ state. When a lift at a node is nullified it moves the lift into the \void\ state. If the state is either \good\ or \void\ then the lift is in a final state. In the model, there are 4 nodes: the originator, two relay nodes, and the referee. This property checks that all of these nodes eventually are in a final state. 

\begin{definition}[Property 2]
    
\begin{multline*}
P_2 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorstate = \relayastate = \relaybstate = \refstate) \\
\end{multline*}
\end{definition}
The purpose of $P_2$ is to verify that the nodes reach a consensus on the final state of the lift. To check that all nodes are in agreement on the state of the lift we check that the originator's state is equal to the first relay's state, the first relay's state is equal to the second relay's state, and that the second relay's state is equal to the referee's state. This implies by transitivity that all nodes have the same final state. 

\begin{definition}[Property 3]
\begin{multline*}
P_3 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorsuccbal + \originatorpredbal \ge 0) \wedge
    (\relayasuccbal + \relayapredbal \ge 0) \wedge
    (\relaybsuccbal + \relaybpredbal \ge 0) \\
\end{multline*}
\end{definition}

The purpose of $P_3$ is to verify that the balance of every active node on the final state of the lift is equal to or greater than its initial balance. We record the change in a node's balance with its partners rather than its total balance. In a successful lift, we expect $B^s + B^p = 0$. However, if a node fails and stops transmitting, its successor might obtain the signature from the referee. When it does so it can use it to collect chips from its successor without needing to send chips to its predecessor. This is an allowable result so we allow $B^s + B^p \ge 0$.

\begin{definition}[Property 4]
\begin{multline*}
P_4 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorsuccbal = \relayapredbal) \wedge
    (\relayasuccbal = \relaybpredbal) \wedge
    (\relaybsuccbal = \originatorpredbal) \\
\end{multline*}
\end{definition}


The purpose of $P_4$ is to ensure that nodes are always in agreement with their partners on the change in the balance between them. 



\subsection{Implementation of Node State Machines} 
To implement the protocol as described by the mealy machine above we need to implement three process types: Originator, Relay, and Referee. Each process has a unique set of edges marked as non-deterministic choices that are enabled only when the current state $S$ matches the state of the edge in the diagram, and---if applicable---when the triggering message is present at the front of a message queue.



\subsection{Implementation of Message Passing}
\subsubsection{Channels}
The message passing between nodes is modeled by creating 3 message channels for each node. One for messages received from the node's successor in the cycle, one for messages from the predecessor and one for messages from the referee. The referee also has a channel where it receives messages.

\subsubsection{Message Types}
The details of the message are not important for the model, instead, each message will have a specific type. It is expected that nodes in a real system will verify that messages are valid as part of processing a received message. For the model, we will consider invalid messages as if they were never received. Once a valid message is received, the type of that message will inform the actions a node will take in response to the message.

\subsubsection{Message Loss}
Rather than using the channels directly, the state machines for each node use helper functions to send messages. There are 3 functions: \emph{sendToPred} which sends a message to the predecessor in the cycle, \emph{sendToSucc} which sends to the successor, and \emph{sendToReferee} which sends to the referee. These helper functions determine which node the message should be sent to and puts the message in the appropriate channel. These helper functions also model the possibility that a message might be lost in transit. Whenever a message is sent, Spin models it as a non-deterministic choice on whether the message should be placed in the appropriate message queue or dropped. In its model checking, Spin will evaluate all combinations of lost messages. One unique case is the possibility that all messages from a given node are dropped. This models the case where a node crashed or otherwise lost connection to the network. 

The protocol requires that the referee should be a node that is consistently available so messages to and from the referee are never dropped. This is required to prove some of the required liveness properties. Without this requirement, the problem is isomorphic with the \emph{two generals problem}, and it is impossible to guarantee eventual consensus on the lift status. This requirement enforces that eventually every message sent to and from the referee will be received, however, the model will evaluate the possibilities that arise should those messages take a very long time. 

\subsection{Modeling Time}
\label{sec:model_time}
Because we don't expect nodes to have synchronized clocks, modeling time for each node becomes extremely computationally complex. Rather than modeling time explicitly, we allow all decisions that would be made by a node based on time to be a non-deterministic choice. This allows the model to explore all combinations of time-drift and all behavior that could arise without the need to model time. Leaving out time reduces the state space considerably and makes the analysis computationally feasible. 

\subsection{Results}

To verify each of these properties, Spin evaluated 
577244 unique states with 240285 edges between those states. Evaluating each property spin found that there were no counter-examples that both satisfied the fairness property and violated one of the properties. We also verified that the fairness property is satisfied in some (presumably all but very few) cases. 

From these results, we can conclude that the properties hold for a system with one originator, two relay nodes, and one referee, for all possible orderings and types of messages sent and for all combinations of messages failing to be delivered. This verifies Lemma \ref{lemma:base_system} as described in Section \ref{sec:extending}.

\section{Inductive Proof} \label{chap:coq_results}
We would like to prove that a chain of n relay nodes conforms to a single relay node for nodes as implemented in the inductive proof.
$$\forall n \in \mathds{N}, \tracestruc{[N_0, N_1, ... N_n]} \preceq \tracestruc{N_0}
$$
Where $\tracestruc{N_0}$ denotes the trace structure generated by the node $N_0$ and $\preceq$ denotes the conformation relation described by Dill.

A trace structure of some implementation $T_I$ conforms to some specification $T_S$ if $T_I$ can be safely substituted for $T_S$. More precisely, $T_I \preceq T_S$, if $T_I$ can accept every input that $T_S$ can, and every output of $T_I$ is a possible output of $T_S$ \cite{uofu_conformance}.

This can be described in terms of the set of accepted inputs and the set of possible outputs for each node in a chain of relay nodes.
$$\inputset{T_S} \subseteq \inputset{T_I}$$
$$\wedge$$
$$ \forall I \in \inputset{T_S}, \outputset{T_S}{I} \supseteq \outputset{T_I}{I} $$

Where $\inputset{T_S}$ denotes the set of inputs that $T_S$ accepts without failure, and $\outputset{T_S}{I}$ denotes the set of outputs that could be generated by $T_S$ with the given input $I$.

This logic is mirrored in the Liskov Substitution principle. If the set of accepted inputs to a replacement module is at superset of, or equal to the set of accepted inputs in the original, and if the set of possible outputs of a module is a subset of, or equal to the set of possible outputs of the original, then it can be safely swapped out \cite{liskov_substitution}. 

In the context of the problem at hand we must show that:
$$\forall n \in \mathds{N}, 
\inputset{N_0} \subseteq \inputset{[N_0, N_1, ... N_n]}$$
$$\wedge$$
$$ \forall n \in \mathds{N}\ I \in \inputset{N_0}, \outputset{N_0}{I} \supseteq \outputset{[N_0, N_1, ... N_n]}{I} $$

Where $\inputset{N_0}$ denotes the set of inputs accepted by the node $N_0$ and $\outputset{N_0}{I}$ denotes the set of possible outputs for node $N_0$ given it receives the input $I$. 


\subsection{Methods}
Coq is a popular interactive theorem prover that can be used to define and prove properties. Inductive reasoning techniques can be used in Coq to state and prove properties of arbitrarily large systems. 


In order to prove Lemma \ref{lemma:chain_conform} we will need to define how a relay node or a chain of relay nodes responds to a particular input and prove properties about the observed inputs and outputs. To do this it is helpful to define the form that inputs take. The simplest approach to define these inputs is to include a basic model the originator and referee sufficient to generate inputs to the relay nodes. 
Each of the definitions of how relay nodes, the originator, and the referee respond to various actions are encoded in a series of validity rules. These validity rules are a predicate on a trace of actions that occur in a system.

The rest of this section describes the machine-checked proof that shows that all possible traces that satisfy the validity rules for a system of arbitrary size $n$ can be \emph{projected} to a base system of size $3$ without changing the inputs or outputs of the remaining nodes. Because the inputs and outputs of all nodes in a system are invariant on the size of the system, we know that 
$\inputset{N_0} = \inputset{[N_0, N_1, ... N_n]}$ and that $\forall I \in \inputset{N_0}, \outputset{N_0}{I} = \outputset{[N_0, N_1, ... N_n]}{I}$.
This implies that
$\tracestruc{N_i} \preceq \tracestruc{N_m}$.
The details of the implementation can be 
found in the \coderepository.

\subsection{Definitions} \label{sec:definitions}
The MyCHIPs system in the Coq proof is written with a \emph{black box} approach. The Coq proof does not need to know anything about the internal state of each of the nodes. To prove that a larger system conforms to a smaller system we need only show that the set of possible inputs and outputs of each node are equivalent regardless of the size of the system. Because of this, many of the variables in the Spin model, including the current balance, and each nodes lift state are omited from the Coq definitions. 

Rather than considering each individual node in the system, the Coq proof operates on traces of actions that might occur in the system. Each trace is represented by an ordered list of \emph{Actions}. The list represents the actions that each node took in the system in the order that they took them.

We define rules that must hold for a trace of actions to be considered valid. We define these rules such that all possible traces of actions in the system are considered valid, and all impossible traces are considered invalid. These rules include properties that are enforced by the MyCHIPs protocol as well as properties that are intrinsic to any distributed system. For example, we enforce  messages can only be received after the message has been sent.

If a node requests the status from the referee but that referee responds with a \pend\ response, those actions do not affect node state so are omitted from the proof's action trace.

Each node in the cycle has a unique ID represented by a non-negative integer. The Originator's ID is 0, with all other nodes in the system having some ID greater than 0. The referee does not have an ID but instead, the special SendRef and ReceiveRef actions are used for communication with the referee. 

\subsubsection{Validity Rules} \label{sec:validity_rules}
The rules that determine if a trace of actions is valid are defined in \emph{acts\_valid}. There are 8 rules:

\begin{enumerate}
  \itemsep 0pt
  \item \emph{has\_required\_actions}
  \item \emph{has\_no\_duplicate\_receives}
  \item \emph{all\_receives\_causal}
  \item \emph{all\_sends\_triggered}
  \item \emph{all\_ids\_in\_range acts}
  \item \emph{promise\_forward\_commit\_backward}
  \item \emph{phase\_sequence\_correct}
  \item \emph{all\_ref\_receives\_causal}
\end{enumerate}

All must hold for a trace of actions to be considered valid. The rules were designed to match the possible traces that could be generated by a system of nodes for the given size. All of these rules are defined formally below and described in detail in Appendix \ref{apdx:coq_detail}.

For the following definitions, we define an action type 
\begin{definition}[Action Type]
$$\action \equiv \{(Send, s, d, m), (Receive, d, m), (SendRef, s) (ReceiveRef, d)\}$$

Where $s \in \mathds{N}$ is the source identifier $0 \le s < size$, $d \in \mathds{Z}$ is the destination identifier $-1 \le d \le size$, and $m$ is a message $m \in \{\promise, \commit\}$.

\end{definition}
For the following definitions we use the notation: 
$A \equiv (a_1, a_2, ..., a_n), a_i \in \action,$ as well as a denote the size of the system $S \in \mathds{N}$ which is a count of the number of nodes in the system.

\begin{definition}[has\_required\_actions] The trace contains the required Sends and Receives with Promise Messages, and nodes before a given failure point $m$ have the required Sends and Receives with Commit messages, or if they are after a given failure point they request the lift status from the referee.

$$
   \forall n \in \mathds{N}, n + 1 < S \longrightarrow \\
   (Send, n, n+1, Promise) \in A \wedge (Receive, n, Promise) \in A\ \\
$$
$$ \wedge \\ $$
$$
   \exists m \in \mathds{N}, \forall n \in \mathds{N}, \\
$$
$$
   (n \ge m) \longrightarrow (n + 1 < S) \longrightarrow \\
   (Send, n+1, n, Commit) \in A \wedge (Receive, n, Commit) \in A\ \\
$$
$$ \wedge \\ $$
$$
   (n < m) \longrightarrow (n < S) \longrightarrow \\
   (SendRef, n) \in A \wedge (ReceiveRef, n) \in A\ \\
$$
$$ \wedge \\ $$
$$
    (Send, 0, -1, Commit) \in A \\
$$
\end{definition}

\begin{definition}[has\_no\_duplicate\_receives]
The trace contains at most one of each receive action. 
$Given\ r = (Receive, d, m), n \in \mathds{N}, m \in \emph{Message},\ \sloppy{\sum_{A}[x=r]} \le 1$. Which counts the number of occurrences where $x=r$ in $A$. 
\end{definition}

\begin{definition}[all\_receives\_causal]
Every \emph{Receive} action is preceded by a corresponding \emph{Send} action. 
Given $r = (Receive, d, m), r \in A \longrightarrow \exists a = (Send, s, d^*, m), a \in A \wedge d^* = d \mod S \wedge a \happensbefore r.$ Where $\happensbefore$ is the happens-before relation over $A$, indicating that $a$ occurs before $r$ in the trace of events. 
\end{definition}

Because we allow the destination of a \emph{Send} to be an integer between $-1$ and the size \emph{inclusive} this means that a node can send a message with a destination $-1$ and this always corresponds with the node with the maximum ID in the system. Additionally, a node might send a message with the destination $n$, but when we project to size $n$ the node with ID $n$ is removed from the system. This send---instead of being sent to a node that doesn't exist---now gets mapped to node $0$ because the destination need only be equal modulo the size. This allows for the projection to work without the need to mutate actions, which makes proving properties about the projected system much simpler.  

\begin{definition}[all\_sends\_triggered] Only the originator sends a message without first receiving a message of the same type.
Given $a = (Send, s, d, m), a \in A \wedge s \neq 0 \longrightarrow \exists r, r = (Receive, s, m) \wedge r \in A \wedge r \happensbefore a$
\end{definition}

\begin{definition}[all\_ids\_in\_range] Ensures the trace only includes identifiers for nodes that are in a system of the given size. Destinations of a send are allowed to \emph{wrap} by one identifier. Given $a \in \action, a = (Send, s, d, m) \longrightarrow 0 \le s < S \wedge -1 \le d \le S$
\end{definition}

\begin{definition}[promise\_forward\_commit\_backward] All Promise messages are sent to the successor in the cycle and all Receive messages are sent to the predecessor. Given $a = (Send, s, d, m), a \in A \longrightarrow [(m = Promise \longrightarrow d = s + 1) \wedge (m = Commit \longrightarrow s = d + 1)]$
\end{definition}
\begin{definition}[phase\_sequence\_correct] The originator sends the first Commit message, and the originator is the last to receive each type of message. Given $a, b \in A$,
$$ 
a = (Send, 0, -1, Commit) \longrightarrow 
$$
$$
[
(b = (*, s, d, Commit) \wedge (s \neq 0 \vee d \neq -1) \longrightarrow a \happensbefore b)
\wedge 
(b = (Send, s, d, Promise) \longrightarrow b \happensbefore a)
]
$$
$$
a = (Receive, 0, m) \longrightarrow 
$$
$$
[
b = (Send, s, d, m) \longrightarrow b \happensbefore a
]
$$
\end{definition}
\begin{definition}[all\_ref\_receives\_causal] No nodes receive a message from the referee before they have sent a message to the referee. Given $r = (ReceiveRef, d), r \in A \longrightarrow \exists a = (SendRef, d), a \in A \wedge a \happensbefore r$
\end{definition}


\subsection{Projection}
Projection is defined with the \emph{projected} function. Given the size of the system we would like to project onto and an action, the \emph{projected} function determines if a given n action is kept or omitted in the projected trace. It uses a special type  
$option \action \equiv \{\emph{None}, \emph{Some a}\}$ with $a \in \action$.

\emph{projected} returns $\emph{None}$ if the given action, $a$,  should be omitted and $\emph{Some}\ a$ if the action should be kept in the projected trace.

\begin{definition}[projected]
\begin{multline*}
a = (Send, s, d, m) \longrightarrow \\
s \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
d > S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (Receive, d, m) \longrightarrow \\
d \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (SendRef, s) \longrightarrow \\
s \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (ReceiveRef, d) \longrightarrow \\
d \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
\emph{Otherwise} \longrightarrow \\
\emph{projected}(a, S) = \emph{Some}\ a\\
\end{multline*}
\end{definition}


\subsubsection{Mutations}
The type of the projected function would allow mutations of actions if necessary. Early attempts at the proof mutated actions to \emph{wrap} a sent message around to $0$ or $size-1$ when the destination was projected out. However, allowing actions to mutate as part of the projection increased the complexity of the proof. Using the modulo arithmetic construct to handle wrapping provides a more robust mathematical foundation. In the final proof, the projeciton never mutates actions only omits them if necessary. 

\begin{definition}[project\_to\_size]
Given a size and a list of actions, \emph{project\_to\_size}, denoted $\mathds{P}$, returns a new list of actions that omits all actions for which \emph{projected} returns None. 
$$
a \in A \wedge projected(a, s) = Some\ a \longrightarrow a \in \projectsize{A}{s}
$$
$$
projected(a, s) = None \longrightarrow a \notin \projectsize{A}{s}
$$
\end{definition}

\subsection{Proofs}

The proof consists of a set lemmas that progressively build from basic principles to the main conformance property we would like to prove. This main theorem ensures that the set of inputs and outputs for each node in the system is invariant on the size of the system. 
This main theorem proves that Condition \ref{itm:inductive_proof} described in Section \ref{sec:extending} holds. This main theorem utilizes many sublemmas to aid in the proof.
The \emph{stack} of supporting lemmas is visualized in Figure \ref{fig:coqLemmaStack}.


The main theorem proven in the coq script is called \sloppy \emph{all\_valid\_systems\_conform\_to\_size\_3}. 
The symbols $\mathds{V}$ and $\mathds{P}$ are used for \emph{acts\_valid} and \emph{project\_to\_size} respectively. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.35]{CoqLemmaStack.png}
    \caption{Stack of Supporting Lemmas}
    \label{fig:coqLemmaStack}
\end{figure}

\begin{theorem}{all\_valid\_systems\_conform\_to\_size\_3}
\label{thm:main_conf}
$$\forall A \in \listaction\ \actsvalid{A}{n} \wedge n > 3 \longrightarrow \actsvalid{\projectsize{A}{3}}{3}.$$
\end{theorem}
This main theorem is proven by induction on $n$: the size of the original system. It begins by eliminating cases where the system size is smaller or equal to 3, then uses a lemma \emph{larger\_conforms\_to\_smaller} to prove it holds for the system of size 4. We then use the lemma \emph{projected\_larger\_conforms\_to\_smaller} which is similar to \emph{larger\_conforms\_to\_smaller} except that it operates on a system that has already been projected. This allows us to reduce the size of the original system by one in each step until we reach the 3-node base case which was proven previously.  In this way, these lemmas can be used to execute an inductive step that proves the property. 

\begin{lemma}{larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ \actsvalid{A}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$
\end{lemma}

The \emph{larger\_conforms\_to\_smaller} lemma proves that all systems of size $n+1$ conform to a system of size $n$. This lemma relies on sublemmas that prove that most of the validity rules are independent of projection. Meaning if the rule holds in a system they continue to hold when projected to a smaller system. The only exception is the \emph{all\_receives\_causal} rule which is not independent of projection. Instead, we use a lemma \emph{valid\_implies\_all\_receives\_causal\_in\_proj} which shows that any valid system still maintains the \emph{all\_receives\_causal} rule in the projected system. Details of those proofs are described later in this section. 


\begin{lemma}{projected\_larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ n \in \mathds{N}, \actsvalid{\projectsize{A}{n+1}}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$
\end{lemma}
This lemma is used as an intermediary step between the original large system and the projection down to size 3. It states that given a set of acts of some larger size $m$, if that larger system when projected to size $n+1$ is valid that implies that the system when projected to size $n$ is valid.

It makes use of a sublemma \emph{project\_idempotent} which proves that projecting to some size $n$ and then projecting to some smaller size $m$ is equivilant to projecting directly to the smaller size $m$. This combined with the lemmas proving the rules are independent of the projection used in \emph{larger\_conforms\_to\_smaller} prove this property.

\begin{lemma}{project\_idempotent}
$$\forall A \in \listaction\ n0\ n1 \in \mathds{N}, n0 < n1 \longrightarrow \projectsize{\projectsize{A}{n1}}{n0} = \projectsize{A}{n0}.$$
\end{lemma}
This lemma proves that projecting first to a larger size, $n$, then to a smaller size, $m$, is equivilant to projecting to size $m$ directly. This is proven directly through induction on the list of actions, and case analysis of each type of action. 

The intuition is that actions are removed when one of there parameters is smaller then the size. Because $n>m$ we know that if an action was omitted in the projection to size $n$ then it also is omitted in the projection to size $m$.  

\begin{lemma}{has\_required\_actions\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \hra{A}{n+1} \longrightarrow \\
\hra{\projectsize{A}{n}}{n}
\end{multline*}
\end{lemma}


This lemma proves that if a trace of actions has all the required actions for size $n+1$ that implies that when that trace of actions is projected to size $n$ it also has all the required actions for size $n$. 

The intuition for this lemma is that the actions that are projected out are precisely the actions that are no longer required for the smaller system. The proof examines each type of action that is required and shows that action is also required in the larger system. This implies that the action exists in the original list. We then show that that action remains in the list after the projection.

\begin{lemma}{has\_no\_duplicate\_receives\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \hndr{A} \longrightarrow \\
\hndr{\projectsize{A}{n}}
\end{multline*}
\end{lemma}
This lemma proves that if a trace of actions does not have more then one receive to the same destination of a given type that implies that when the trace is projected to size $n$ it still has no duplicates.

This is proven by induction on the trace of actions, with the core intuition being that the projection can not introduce any new actions. This is proven in the sublemma \emph{not\_in\_orig\_not\_in\_proj}. 


\begin{lemma}{valid\_implies\_all\_receives\_causal\_in\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \actsvalid{A}{n+1} \longrightarrow \allrc{\projectsize{A}{n}}{n} $$
\end{lemma}
This lemma is the least trivial and the core problem that needed to be proven to show that the larger system conforms to the smaller system. The receive causality property is difficult because a \emph{Send} action that is associated with a given \emph{Receive} in the original system may be removed in the projection. However, if the \emph{Send} for a \emph{Receive} is projected out there is an equivalent \emph{Send} from that node's predecessor that now can be matched with that \emph{Receive}. 

This lemma is proven by careful case analysis. The proof itself spans nearly 500 lines and makes use of information known about the trace of actions based on the \emph{acts\_valid} assumption. 

We begin by introducing an action $r$ which is the \receive\ in question. We assume it exists in the projected list and that it is indeed a \receive\ and use the sublemma \emph{in\_proj\_in\_orig} to show that the action must also appear in the original trace. 

With the knowledge that the action was in the original trace the assumption of the validity of the original trace allows us to show that there must be a corresponding \send\ for that \receive\ in the original trace. 

We now know that there is a \receive\ that is both in the original trace and in the projected trace and that there is a corresponding \send\ in the original trace. From here we examine the possible scenarios for what happens to the corresponding \send\ in the projection.

These scenarios are:
\begin{enumerate}
\item \label{case:normal} Both are unchanged. Neither the \send\ nor the \receive\ are removed and neither \emph{wrap} around in the modulus.
\item \label{case:src_wrap} The \send\ alone is projected out. The source of the \send\ refers to a node that is no longer in the system.
\item \label{case:dest_wrap} The \send\ destination alone is projected out and the send now \emph{wraps}.
\item \label{case:both_wrap} Both the \send\ source and the send destination refer to a node that is removed. 
\end{enumerate}


Scenario \ref{case:normal} is pretty straightforward, the \send\ for the \receive\ is the exact same \send\ as in the original trace. We just show that the send remains in the projection.

Scenario \ref{case:src_wrap} is tricky. The previously associated \send\ is now projected out. But the \receive\ is not projected out. To prove this scenario we use information about the required actions in the original trace. After unpacking this information we can show that there must be a \send\ that would have gone to the node that was projected out. We show that this \send\ \emph{wraps} due to the change in the size in the modulus which means that that send is now associated with the \receive\ in question.

Scenario \ref{case:dest_wrap} is the dual of scenario \ref{case:src_wrap}. The same problem but from the other perspective. This is the case where a node that is not projected out sends to a node that is projected out. We show that that message \emph{wraps} to connect with a new \receive\ which is our \receive\ in question. 

Scenario \ref{case:both_wrap} is an interesting case because it is only possible if we project out more than one node in a single step. The way the property is defined this is not possible because we have a system that is valid for size $n+1$ that is projected to size $n$. It takes some mathematics and a few properties about modular arithmetic to show that this case is impossible and always leads to contradictions.

%Probably not worth mentioning here. They can see it in the script if they want.
%There is one final scenario in the proof not listed above. It is the case where the destenation of the receive is projected out. This comes out as an implementation detail for how we obtained some information about the original destination. We assumed that the original destination was either less then the new size or greater or equal to it. Then we checked each case. The case where the destination was greater or equal to the new size is easily dismissed by noting that that would mean that the recieve that needs a send was projected out, which is a contradicition with the assumption that it is in the projected trace.

Once each of these cases were individually proven or shown to lead to contradictions the property proves out.

\begin{lemma}{all\_sends\_triggered\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allst{A} \longrightarrow \allst{\projectsize{A}{n}} $$
\end{lemma}
This lemma shows that if \emph{all\_sends\_triggered} holds in the original system it continues to hold in the projected system. This property enforces a partial order of events.

The intuition of this proof is that projections don't affect the order of events. This is proven concretely in the sublemma \emph{happens\_before\_independent\_of\_proj} which is used several times in this proof. 

\begin{lemma}{all\_ids\_in\_range\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allir{A}{n+1} \longrightarrow \allir{\projectsize{A}{n}}{n} $$
\end{lemma}
This lemma proves that there are not any actions associated with nodes that would not be present in a system of the given size. It can be directly poven based on the definition of \emph{projected}. 

\begin{lemma}{promise\_forward\_commit\_backward\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \pfcb{A} \longrightarrow \\
\pfcb{\projectsize{A}{n}} 
\end{multline*}
\end{lemma}
This property requires that the source and destination fields in Send actions follow certain patterns. The intuition of this proof is that projection does not mutate fields. We simply show that any projected item must have been in the original list. Because this property holds in the original list this property holds in the projected list.

\begin{lemma}{phase\_sequence\_correct\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \psc{A} \longrightarrow \\
\psc{\projectsize{A}{n}}
\end{multline*}
\end{lemma}
This property also imposes a partial order on traces. It is proven similar to \emph{all\_sends\_triggered\_independet\_of\_proj}, by showing that projections don't effect the order of events using the sublemma \emph{happens\_before\_independent\_of\_proj}. 

\begin{lemma}{all\_ref\_recieves\_causal\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allrrc{A} \longrightarrow \allrrc{\projectsize{A}{n}} $$
\end{lemma}
This property requires that if a node receives a message from the referee it first sent a message to the referee. The intuition of this proof is that if a SendRef action that requested the status from the referee is projected out that implies that the ReceiveRef action is also projected out.

\begin{lemma}{not\_in\_orig\_not\_in\_proj}
$$ \forall A \in \listaction\ a \in \action\ n \in \mathds{N}, a \notin A  \longrightarrow a \notin \projectsize{A}{n} $$
\end{lemma}
This lemma shows that if an action is not in the original trace of actions it cannot be in the projected trace of actions. It is proven by induction on the trace of actions. It uses a proof by contradiction. We assume that the action is not in the original list but is in the projection. Then using the lemma \emph{in\_proj\_in\_orig}, we show that it must also be in the original list. This contradicts our first assumption.

\begin{lemma}{in\_proj\_in\_orig}
$$ \forall A \in \listaction\ a \in \action\ n \in \mathds{N}, a \in \projectsize{A}{n} \longrightarrow  a \in A $$
\end{lemma}
This lemma shows that if an action exists in the projected system then it must have existed in the original system. In other words, projection does not introduce new actions.
 It is proven by induction on the list of actions. The base case, an empty trace, easily leads to a contradiction. Then when considering a single action use the definition of \emph{project\_to\_size} to show that the action must have come from the original trace. 

\begin{lemma}{happens\_before\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N},
a\ b \in A \wedge a\ b \in \projectsize{A}{n} \wedge a \happensbefore b \longrightarrow a \prec_{\projectsize{A}{n}} b
$$
\end{lemma}
This is the core lemma showing that projection doesn't reorder actions in the trace. It is proven by induction on the trace of actions. 

The base case, an empty trace, is easily dismissed with a proof by contradiction. 
Then when we consider a trace of actions with one additional action prepended to the trace. We call this new action $x$. On this new trace, we know that the action $a$ happens before the action $y$.
We can examine what might happen to $x$ in the projected trace.
We know that an action either remains in the projected trace or is removed entirely from the projected trace.
We will consider both of these cases.

If $x$ remains in the trace then it becomes the first item in the trace. 
We then consider the possible cases for what $x$ is.
$x$ could be equal to $a$, it could be equal to $b$, or it could be neither $a$ nor $b$.
If it is equal to $a$ then because it is the first item in the trace it must happen before $b$.
If it is equal to $b$ it means that $b$ must happen before $a$, however, $x$ is also the start of the unprojected trace so we can show that that is a contradiction with our assumption that $a$ happens before $b$ in the original trace.
If $x$ is either $a$ nor $b$ then it does not have any bearing on whether $a$ happens before $b$ or not. We can then consider the rest of the trace to check that $a$ happens before $b$ in the subtrace. This reduces the problem to our inductive hypothesis.

Finally, we must consider the case where $x$ is removed from the trace in the projection. This immediately reduces to the inductive hypothesis which allows us to prove that the \emph{happens\_before} property is independent of projection.

\subsection{Results}
Theorem \ref{thm:main_conf} tells us that the set of possible trace actions taken by each node in a system is independent of the size of the system. Because this is true for each node in a chain of n nodes we know that the inputs received by a chain of n nodes are equivalent to the inputs received by a single node. Similarly, the outputs of a chain of n nodes are equivalent to the output of a single node. This in turn implies that a chain of n nodes conforms to a single node.
\begin{multline*}
\\
\forall A \in \listaction\ \actsvalid{A}{n} \wedge n > 3 \longrightarrow \actsvalid{\projectsize{A}{3}}{3} \longrightarrow \\
\inputset{N_0} = \inputset{[N_0, N_1, ... N_n]}
\wedge 
\forall I \in \inputset{N_0}, \outputset{N_0}{I} = \outputset{[N_0, N_1, ... N_n]}{I} \longrightarrow \\
\forall n \in \mathds{N}, \tracestruc{[N_0, N_1, ... N_n]} \preceq \tracestruc{N_0} \\
\end{multline*}

Thus we see that Lemma \ref{lemma:chain_conform} must be true.

\section{Proving safe substitution}
\label{sec:inputs_map}
We would like to prove Lemma \ref{lemma:ind_cof_model}:
$$\tracestruc{N_i} \preceq \tracestruc{N_m}$$

The core question posed by this lemma is:
Can we replace a node as implemented in the Spin model with a node as implemented in the inductive proof?

Using similar logic as described in Section \ref{chap:coq_results} we can show that the conformance relation we wish to prove is equivilant to:
$$\inputset{N_m} \subseteq \inputset{N_i}
\wedge
\left[\  \forall I \in \inputset{N_m}, \outputset{N_m}{I} \supseteq \outputset{N_i}{I})\ \right] $$

We will consider the left side and the right side of the disjunction separately. 
Section \ref{sec:inputs_smaller} discusses how the Spin model was adjusted to verify the left side.
Section \ref{sec:outputs_bigger} argues that the right side holds.

\subsection{The inductive proof's accepted inputs are a superset of the model-checking accepted inputs}
\label{sec:inputs_smaller}
If $\inputset{N_m} \nsubseteq \inputset{N_i}$ then there must exist a trace explored by Spin that breaks the validity rules. By encoding the validity rules as properties in Spin, we can then verify that the rules hold for all of the traces evaluated by Spin. 

To implement the properties to match the Coq rules the Spin model needed to be extended to generate a data structure that recorded the trace of actions. This data structure is referenced in the new properties to verify the rules about traces hold. Because the actions considered in Coq are all inputs and outputs of nodes, to generate this trace of actions it was only necessary to adjust the helper functions that send messages and then add a few lines to add actions to the trace when a message is received. 

After making these adjustments the validity rules can be written in Spin as properties, then Spin will evaluate each trace of events to ensure that the properties hold. 

When Spin verifies these properties it produces some counter-examples which we would like to exclude. These counterexamples are cases where---because messages are lost---a \promise\ message does not reach each node. This violates the \emph{has\_required\_actions} rule. However, these traces would be valid for a system of size smaller than 3. Because we are interested only in mapping the Coq proof to the spin model for the base system, we want to introduce a new fairness property that eliminates cases that represent systems smaller than the base system. This property requires that each node eventually leave the \emph{no\_lift} state. After triggering on this fairness property, each of the validity rules verify for all traces evaluated by Spin. 

Similar to the previous fairness property we added a check to ensure that the new \emph{of\_size\_3} property is achieved. This check passes.

These results verify that 
$\inputset{N_m} \subseteq \inputset{N_i}$. 

\subsection{The inductive proof's outputs are a subset of the model-checking outputs}
\label{sec:outputs_bigger}
We can observe that the only communication that a node has is with its successor or its predecessor in the ring or with the referee. This is true for nodes as defined in the inductive proof, as well as for nodes as defined in the model-checker. 
We can examine all the possible combinations of messages for a single node to its predecessor, its successor, and the referee. Because a node might send more then one message of a given type this set is potentially infinitely large. However, receiving a message in the MyCHIPs system is idempotent. Receiving a message of the same type twice does not affect the state of a node. Because of this The set of possible outputs we need to can be reduced into a small set of equivalence classes where each possible output is represented by a canonical member that has only one of each type of message.

We can define these equivalence classes as an ordered list of actions with the property that each type of action appears in the list at most one time. 
We use the notation $P$ to denote a promise sent to the successor, $C$ to denote a commit sent to the predecessor, $S$, to denote a status request to the referee. We ignore receive actions as those are always inputs and we are concerned only with outputs.
For example: $[P, S, C]$ is the case where the node sends a \promise\ then sends a \emph{status} request, then sends a \commit.

These equivalence classes are:
\begin{enumerate}
    \item $[S]$
    \item $[P, S]$
    \item $[S, P]$ \krs{This was not found! Mealy machine acts right away! But the receive could be later...}
    \item $[P, C]$
    \item $[P, S, C]$
    \item $[S, P, C]$
\end{enumerate}

We can evaluate if each of these equivalence classes is considered in the Spin model by generating a property that asserts a trace of that class is not present, similar to the existential check for the fairness property described in Section \ref{chap:model_checking_results}. If Spin verifies that each equivalence class is present then and we can conclude that Lemma \ref{lemma:ind_cof_model} holds.

Using the same adjusted model described in Section \ref{sec:inputs_smaller} we can write these properties. These properties are existential properties so no fairness constraint is needed. All of these equivalence classes are observed in the Spin model. This allows us to conclude that:
$$\forall I \in \inputset{N_m}, \outputset{N_m}{I} \supseteq \outputset{N_i}{I})\ $$

\krs{TODO: I still need to add this to the mapping spin model.}

\section{Assuring all nodes in the system are verified}
\label{sec:nodes_map_base}
We would like to prove Lemma \ref{lemma:all_nodes_covered}. 
$$
\forall N \in S, \exists N' \in \basesystem, \tracestruc{N'} = \tracestruc{N}.
$$
The core question asked by this Lemma is:
Do all nodes in a large system have an analog in the base system?
To prove this we need to show that we can construct a system with an arbitrarily large number of nodes by replacing nodes in the base system with a chain of n nodes such that an arbitrarily selected target node is a node that was originally in the base system.

\egm{Move this into it's own section. Admit the lemma here, as needed for the proof, and in that later section, make the best argument possible and state that future work is to strengthen. The following paragraph and algorithm would go to that section.}
\krs{Moved from Section 3 here}

For example, if we would like to verify the properties hold for the node with ID 6 in a 15-node system, we construct a system where that node is unreplaced. To do this can choose to replace the originator with a chain of 6 nodes (including a new node with ID 0 to act as the originator). We then leave the first relay node in place as our desired 7th node (ID 6). Then we replace the second relay node with a chain of 8 nodes. We know that those substitutions are safe substitutions so we know the constructed system conforms to the base system. i.e. the target node cannot tell the difference between the base system and the newly constructed system. From this, we know that the properties hold for the target node. 

This method can be generalized to construct a system of arbitrary size to verify the properties of an arbitrarily selected target. This generalization is described by Algorithm \ref{alg:const_ver}.


\begin{algorithm}
\caption{Constructing a verified system}
\label{alg:const_ver}
\begin{algorithmic}
\State let $i \in \mathds{N}$ be the target ID, $s \in \mathds{N}$ be the target size.
\If{$i = 0 \vee\ i=(s - 1)$}
    \State Replace \emph{Relay 1} in base system with a chain of $(s - 2)$ nodes.
    \State This is the verifying system.
\Else
    \State Replace the \emph{Originator} in base system with a chain of $i$ nodes.
    \State Replace \emph{Relay 2} in the base system with a chain of $(s - i - 1)$ nodes. 
    \State This is the verifying system.
\EndIf
\end{algorithmic}
\end{algorithm}


Because we can construct the system $S$ by replacing nodes in the base system without replacing an arbitrary target node, we can conclude:
$$\forall N \in S, \exists N' \in \basesystem, \tracestruc{N'} = \tracestruc{N}$$.

\section{Related Work}
\krs{Need to add sections about other results that use conformance, as well as infinite state model checking}


There are numerous bodies of work that solve similar problems or utilize similar constructs. The following list is particularly relevant. 

\subsection{Infinate State Model Checking}
Clarke, Grmberg, and Browne describe a method for verifying properties on systems with many identical subprocesses. This method relies on a proof of bisimulation which is difficult to prove if these subprocesses can make non-deterministic choices as the nodes in the MyCHIPs system can. The method described in this work may have some isomorphism with their method but presents it in terms of conformance and other modern model-checking methods. 

German and Sistla build on the work of Clarke, Grmberg, and Browne, but present a fully automatic method that can reason about multiple identical processes without any manual proofs about those processes. 

German and Sistla's work is referenced by other papers describing methods for model-checking infinite state spaces. The methods at a high level make an adjustment to the state matching to weaken the equivalence relation. Two states may be unique due to some infinite variable (a natural number) being different but they are equivalent in all ways we care about for verifying a property. This allows the machinery that model checks state a system for liveness and safety properties to operate on an infinite state space. This is somewhat akin to abstract interpretation. 

\subsection{Digital Currency Background and Verification}
There are also several papers relating to digital currencies which may be helpful background when considering the MyCHIPs system described in Appendix \ref{apdx:mychips}.

 Nakamoto describes how transferable digital tokens can be double-spent. The paper introduces bitcoins and describes the proof of work method of overcoming this problem which is often referred to as blockchain technology. \cite{bitcoin} 

 Bateman recognizes that the double spending problem is present only in digital currencies that are both duplicatable and transferable. Blockchain technology prevents digital tokens from being duplicated. MyCHIPs instead is designed with non-transferable tokens. MyCHIPs utilizes credit lifts to allow these non-transferable tokens to be virtually fungible and to allow for effective transactions to be made. 
 
 Bhargavan et. al. Verify Smart Contracts \cite{SmartContracts}. Smart contracts are a type of distributed computation where the program that is executed is secured in a blockchain. While not directly related, smart contracts have the same financial stakes MyCHIPs have and some of their techniques could give inspiration.  Bhargavan et. al, translated the smart contract code into a functional programming language, F*, aimed at verification. This allowed for contract verification based on F* type-checking.

 \subsection{Proofs and methods for distributed systems}
 Fischer, Lynch, and Paterson,\cite{Fischer} prove the impossibility of consensus on even a Boolean, with even one faulty (or malicious) process. However, this is only true if the processes don't have synchronized clocks. This proof shows the necessity of the referee with strong reachability requirements for the lift algorithm to always eventually reach a consensus on if the lift should commit or be nullified.
 
 Schneider summarizes and frames many fault-tolerant distributed algorithms in the framework of  machines\cite{StateMachine}. He shows how many common algorithms are isomorphic to, and can be derived using, the state machine approach. It is a helpful method to characterize and compare different approaches and this work is inspired by these methods.
 
 Lamport\cite{Lamport}, describes a refinement process that takes a distributed fault-tolerant consensus algorithm and hardens it to be tolerant of byzantine actors through a process he calls \emph{byzantizing.} This method may be useful in future work to ensure the MyCHIPs pr=otocol follows key principles of Byzantine hard protocols.
 
 Delzanno, Tatarek, and Traverso, model check a common consensus algorithm called Paxos in Spin. Their spin constructs provide helpful examples of how distributed algorithms are efficiently modeled.\cite{Delzanno_2014}
 
 Konnov, Veith, and Widder explore the unsolved problems associated with model checking distributed algorithms. This can serve as a hazard map of difficult unsolved problems. It would be unfortunate if solving a known problem that is tangential to this work becomes a prerequisite to finishing. This also can serve to give context to this work and show how it progresses towards solving some of these problems.\cite{Konnov}

\subsection{Work that uses similar methods for mechanized proofs}
 Huang, Ogles, and Mercer prove that \emph{doesn't commute}, a weakened version of the happens-before relation, is sound for certain common classes of task parallel programs. They present a mechanized proof that proves properties for all traces constrained by a partial order. The methods demonstrated by Huang, Ogles, and Mercer were used as inspiration for some of this work's mechanized proofs. \cite{ben_DC}
 

\appendix

\section{The MyCHIPs system}
\label{apdx:mychips}
The MyCHIPs protocol and the methods used to verify it can be understood independently of the system it is used in. However, the curious reader will want to know more about the context in which the MyCHIPs protocol operates. This section provides an overview of the system. More details can be found on Kyle Bateman's website \cite{bateman_myCHIPs}. 
In particular, this section will cover the common challenges with using digital currency, how existing systems overcome those challenges, and how MyCHIPs overcomes those challenges in a unique way that provides additional benefits. 

\subsection{The two types of Money: Commodity and Credit}
The purpose of money is to be a medium of exchange, and it does so by storing value. When someone provides a good or service, the seller is usually given money in exchange. This money stores the value they provided until the seller is ready to redeem that value to get something they need.
For this to work, whatever is used as money needs to be considered valuable. There are two prevailing methods for accomplishing this: commodity money, and credit money. 

In this context, a commodity is anything that can be owned and that can have its right to ownership transferred from one party to another. A commodity derives its value from the economic laws of supply and demand. Because some commodities are consistently desired and are sufficiently scarce, their value is stable enough to be used as money. For example, gold has historically seen widespread use as commodity money. As long as a commodity is in demand and its supply is reasonably limited, it can likely be used as money.

In contrast, credit money exists as a promise from one party to another of future value--likely a commodity or service. If the party giving the promise is trustworthy, the credit money has value equal to what was promised.
%If not, such pledges may be secured by collateral, which is a promise of ownership of an existing commodity should the pledgor fail to deliver on the promise of future value. 

\subsection{Digital Currencies}
Most digital currencies, including Bitcoin and Ethereum \cite{bitcoin}, take the commodity money approach. This decision led to two key technical challenges: achieving scarcity, and community consensus on ownership.

\paragraph{Achieving Scarcity}
It can be difficult to make a digital object that can be kept scarce.
Physical commodities, such as gold, are difficult to locate and refine. To mirror this difficulty of discovery, a finite set of digital tokens can be mathematically defined in such a way that they were not known specifically in advance. However any token, once discovered, could be easily checked to determine if it belonged to the set. Furthermore, discovering tokens is often computationally complex enough that it requires significant time and energy to discover a new token. This allows for a commodity that is both digital and scarce.
There are many possible sets that could be used, however, hash functions and blockchains became the prevailing method because using this method simultaneously solves the community consensus problem.

\paragraph{Community Consensus}
For someone to transfer ownership of a commodity, it is important for them to be able to prove that they own the commodity. Because of this, using commodity-based money requires community consensus about who owns what commodities.

Community consensus can be difficult to achieve, especially when many malicious actors may be present. One frequently discussed example where community consensus is not successfully achieved is the \emph{double-spending} problem. \emph{Double spending} is a difficult challenge and efforts to solve the problem lead to the development of blockchain algorithms. 

\subsection{Double-Spending}
Double spending is a challenge that arises when using digital commodities as currency. To spend a commodity-based digital token, an entity must send a transmission that convinces a peer that it owns a digital token and is transferring ownership of that token to the peer. However, if the entity can send one transmission that fulfils this, it can easily send the same transmission to two peers simultaneously. If the peers have no means of communicating with each other (or some third party) then they each have no reason not to accept the digital currency. This allows a malicious actor to double-spend a digital token.

\subsection{Overcoming Double-Spending with a Public Ledger}
Most commodity-based digital currencies overcome the double-spending problem is using a public ledger. With a public ledger, each transaction between any entities using the digital currency must be stored in a single public record. By using a public record, double-spending can be identified and prevented. This public ledger may be implemented by assigning a central trusted authority to manage the ledger or it may use a decentralized ledger with a consensus algorithm. 

While using a central trusted authority to manage the ledger is simple, its centralized nature leads to certain risks. First, the central authority is a single point of failure. If the central authority experiences some error and is not able to process transactions for a period of time, all trade using the digital currency would halt. Second, giving the central authority control over all the transactions of a digital currency requires great trust in the authority. The central authority could easily falsify records in order to benefit itself or a third party. In practice, there is not a single authority that every potential user of a digital currency will consider worthy of that amount of trust.

Using a decentralized ledger removes the need for a single trusted authority, but steps must be taken to ensure that the ledger cannot be falsified by an attacker and that a quorum of users eventually agrees on the state of the public ledger. There are two common consensus algorithms used to achieve this: proof-of-work, and proof-of-stake.

\subsubsection{Proof-of-Work}
Proof-of-work consensus algorithms allow for a form of democratic consensus where the group that holds more then 50\% of the computational resources decides the state of the public ledger. The blockchain method accomplishes this by requiring each block to include a partial hash collision. Such a collision will includes a certain number of leading zeros in the result of the hash. Because cryptographic hash functions are designed to be unpredictable and non-reversible, there is no inverse function to compute what data must be added to a record to get the required hash. In order to add a block of data to the ledger an entity must compute many billions of hashes until it finds a partial collision. These blocks are then chained together so the hash of the previous block is included in the next block. 

By chaining these blocks together in order to make a change to a previous block that appears legitimate an attacker must recompute the hash collision for all subsequent blocks. If the attacker does not have more then 50\% of the computation power they won't be able to compute the required hashes faster then the block chain grows and will never be able to make a falsification appear legitimate.

This method has been quite successful at accomplishing its goals, but it has received criticism from the economic and environmental impacts it causes. In order to maintain security of the public ledger the computation work required needs to be great enough to prevent attacks, however computational work is not free. There is very large overhead to purchase and maintain equipment and supply power to be able to complete the computational puzzles required by proof-of-work. This means that transaction costs for block-chain currencies are much higher then traditional transactions. Additionally, the power used for proof-of-work often is generated by burning fossil fuels, which contributes to greenhouse gas emissions and depletes limited resources. Many argue that proof-of-work consensus algorithms are not sustainable. 

\subsubsection{Proof-of-Stake}
In response to these criticisms, algorithms have been implemented that rely on \emph{proof-of-stake} rather then proof of work. Proof-of-stake algorithms rely on similar principles as proof-of-work but rather then allowing anyone to complete the computational puzzle, validators are randomly selected from a pool. To become a validator an entity must place sufficient stake as collateral. If they are found to behave maliciously, their collateral is forfeit. This allows the computation puzzles to be set to be much easier to solve which in turn reduces the overhead and environmental impact of transactions.

\subsubsection{Public Ledgers and Privacy}
Both proof-of-work and proof-of-stake algorithms operate to create consensus on a single, public ledger. The requirement for a public ledger means that no transactions can be made privately. Steps can be taken to attempt to anonymouize transactions but if the identifiers used in the transaction are connected with the individuals they represent, anyone can see the entire history of that person's transactions. Additionally, requiring a consensus on a single public record limits how decentralized the digital currency can be. Because of the privacy concerns, the economic and environmental impact of blockchain transactions, and to make a more decentralized monetary system, an non-blockchain digital currency is desirable. MyCHIPs aims to serve as a credit-based digital currency that avoids these fundamental problems. 

\subsection{Private Credit Digital Currency}

Transferability is intrinsic to commodity money. If you cannot transfer ownership of the commodity you can't transfer the value and it doesn't work as money. Credit money however can be made non-transferable and still maintain value. The promise for goods or services connected with the credit money can be valuable even if that promise is valid only for you. Making tokens non-transferable solves many security problems but leads to other practical problems.

\subsection{Solving the double-spending problem with non-transferability}
To prevent double spending we must ensure that a malicious actor gains no benefit from transferring a digital token to two different peers. Rather then preventing duplication, MyCHIPs instead ensures that tokens are only transferred once. To meet this goal, tokens in the MyCHIPs system are designed to be non-fungible and non-transferable. A token is created for a single recipient and is valid for only that recipient. However, this method has an obvious problem: how does one spend a non-fungible, non-transferable token? MyCHIPs has a method to make CHIPs \emph{virtually fungible} that involves giving the CHIPs back to the issuer in a distributed algorithm called a credit lift.  \cite{bateman_myCHIPs}


\subsubsection{The value of a CHIP}
As mentioned above, blockchain based cryptocurrencies rely primarily on scarcity to drive their value.
Experience has shown how this results in highly volatile valuations over time.
Volatility may be useful in certain investments, but it is generally not desirable in a currency.

In the same way that bonds tend to be less volatile than stocks, a credit-based currency will be more stable than one based on a purely demand-driven commodity.
However, the credit lift algorithm does rely on the assumption that at each stage of the lift, parties are trading tokens that have a uniform nominal value.

This unit of measure is called the CHIP--a clever backronym for Credit Hour in Pool.
The value of a CHIP is defined to be the value of one hour of unskilled labor. Parties agree to this definition in a digital contract when they issue CHIPs. Recent research has placed this value at \$2.53. \cite{bateman_chip_value}

However, if a laborer is providing tools, or has some expertise in the work they may be able to negotiate receiving more than one CHIP for an hour worth of work.
That is up to the market to decide.
The CHIP definition only quantifies what is being promised with the issuance of each new CHIP.

Unfortunately, it is not very common where the seller of a good wants something directly from the buyer in exchange. To make MyCHIPs useful to facilitate trade the seller needs to be able to use the CHIPs to get goods or services from other entities besides the buyer. This is accomplished through a \emph{credit lift} (hereafter, \emph{lift}).

\subsection{Chits and Tallies}
Because a Token in the MyCHIPs is only valid between exactly two entities, these tokens only need to be tracked by those two entities. These tokens are tracked on a consensed record called a \emph{Tally}. A \emph{Chit} is an atomic transaction where one or more CHIPs are given to the partner. A Tally is an ordered collection of Chits with additional information to note the terms of the two entities agreement. 

Whenever a pair of entities desires to establish a trade relationship with each other, they create a new Tally to track that relationship. Most trade relationships are fairly consistent about who is selling goods or services and who is buying. When creating a Tally the entities establish this normal flow by assigning the entity who is usually paid and provides goods the \emph{Stock} role in the Tally, and the one who usually pays the \emph{Foil} role. These names hearken to a traditional method of tracking such credit relationships called a \emph{Split Tally}. If the entity that takes the \emph{Stock} role wishes to purchase goods or services from the \emph{Foil} entity, the entities create a new Tally with the roles reversed.

Each time a transaction is made, the entity with the Foil role creates a Chit that includes: 
\begin{enumerate}
    \item The number of CHIPs being sent
    \item A verifying digital signature
    \item The date and time of the transaction
    \item Other metadata about the transaction
\end{enumerate}
The verifying signature could be either the signature of the entity with the Foil role or as described in section \ref{sec:liftAlgorithm} the signature of the referee if the transaction is part of a credit lift. The verifying signature is all that is needed for one entity to prove the other owes some debt, however, it is helpful for both entities to have assurances that they are in agreement about the balance of their tally. 

To ensure that both entities agree on the state of the Tally, they exchange hashes of their Tally. If the hashes match they can be assured they are in agreement on both the Chits in the tally as well as the order of those Chits. If there is a mismatch, the consensus algorithm is simple: the Tally of the entity with the Foil role is considered correct. If there are still missing Chits, the entity with the Stock re-transmits those to the Foil. The Foil adds those Chits to the Tally and re-transmits its new hash. 

\subsubsection{The MyCHIPs Credit Lift}
A lift makes CHIPs \emph{virtually fungible} by identifying a circuit where every entity holds CHIPs issued by their predecessor in the circuit. The lift algorithm arranges for each entity in the cycle to forgive the debt of their predecessor to get the same amount forgiven by their successor. 
 
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{ExampleCircuit.png}
    \caption{Example Circuit}
    \label{fig:liftProt}
\end{figure}
How this facilitates trade can be better understood by considering a barter system that involves more than two parties. 
For example, Bob needs his car fixed, John wants solar panels installed on his roof, and Cindy wants a well dug. Cindy knows how to fix cars, Bob knows how to install solar panels, and John is able to dig a well. See Fig. \ref{fig:liftProt} for a graphical representation of this arrangement. If they get together, they can work out a trade where John digs the well for Cindy, Cindy fixes Bob's Car, and Bob installs John's solar panels. Everyone would be happy.

But it is difficult to identify the these cycles before every transaction. This is where money comes in. Using government-backed money like dollars or euros, the process for enabling this transaction might go as follows:
\begin{enumerate}
\item Bob gets a loan from a bank
\item Bob uses the money from the loan to pay Cindy to fix his car.
\item Cindy gives that money to John to dig the well
\item John gives Bob the money to install the solar panels
\item Bob uses the money to repay his loan (but he may need to pay a little 
interest).
\end{enumerate}

MyCHIPs solves the same problem but instead does so by explicitly finding these cycles of value. Each person providing goods or services accepts CHIPs as an IOU for the exchange. Then a successful lift discovers this cycle of value and clears the debts of all involved.

If John, Bob, and Cindy were to use a credit lift to facilitate the arrangement it would go as follows:
\begin{enumerate}
\item Bob asks Cindy to fix his car and agrees to give Cindy 10 CHIPs 
\item Cindy gives John 10 CHIPs to dig the well
\item John gives Bob 10 CHIPs to install the solar panels
\item Cindy talks with Bob and learns that John gave Bob 10 CHIPs
\item Cindy realizes that Bob gave her 10 CHIPs, she gave John 10 CHIPS and John gave Bob 10 CHIPs. There is a cycle!
\item Cindy initiates a lift and \emph{promises} Bob that she will forgive his debt if he can get John to do the same for her. By doing this she takes on the role of the \emph{originator} of the lift. 
\item Bob gives John a similar promise.
\item John gives Cindy a similar promise and Cindy knows the deal is on.
\item Cindy \emph{commits} and gives Bob 10 CHIPs to cancel his debt
\item Bob gives John 10 CHIPs
\item John gives Cindy 10 CHIPs
\end{enumerate}
Everyone's tally for how many CHIPs they have given each other now totals to 0.
We can see this exchange allows for virtual fungibility: each person trades some CHIPs they have received to get back some CHIPs they have given out. 
This resets their balances so they can then give more CHIPs out again in exchange for future goods they will need. 

\section{Details of Coq Definitions}\label{apdx:coq_detail}

\paragraph{has\_required\_actions}
The has\_required\_actions rule is designed to check that the set of traces has all of the actions required by the protocol for a system of a given size. There are two sections to this rule that correspond with the promise and commit phase of the protocol. 

For the promise phase, we ensure that each node in the system receives and sends a promise message. In a real system, some messages may be lost which would cause some nodes to not receive a promise message, however, these cases can be considered to be a system of size $n$, where $n$ is the number of nodes who did receive a promise message. 

For the commit phase, we define a failure point $m$. Each node after $m$ may not receive a commit message and must send a status request to the referee. Each node before $m$ must receive a commit message. This failure point is an important construct for some of the required lemmas to prove the main theorem. To maintain this, a real system must not forward a signature obtained directly from the referee. 

The has\_required\_actions rule enforces a minimum requirement for actions that must be present in the trace, additional actions are permitted.

\paragraph{has\_no\_duplicate\_receives}
The has\_no\_duplicate\_receives rule is designed to check that is only one Receive action for each destination and message type. This rule simplifies the \emph{all\_receives\_causal} rule by allowing it to require only that there exists a corresponding send that happens before. Without this rule it would be necessary to match a corresponding send with each receive to ensure that one sent message is not received twice. This would make the proof much more complex. It is a property about how traces should be recorded. A real system must ensure that all responses to a message are idempotent or that duplicate received messages are ignored. 

\paragraph{all\_receives\_causal}
The all\_receives\_causal rule is designed to check that each receive is preceded by a corresponding send. To define this rule we define \sloppy \emph{is\_send\_for\_receive} which given two actions evaluates if the first is a Send and the second is a receive such that the destination of the send is equivalent to the destination of the receive. The equivalent here is defined as equal modulo the size of the system. This allows for messages that \emph{wrap} around the cycle to be considered equivalent without the need to mutate actions during projection. 

We also define a happens\_before function which evaluates to true only if the first action given occurs earlier in the list then the second action. 
Using these two definitions we can check to ensure that every Receive action is preceded by a corresponding send. 

\paragraph{all\_sends\_triggered}
The all\_sends\_triggered rule is designed to check that only the originator sends a message without first receiving a message that triggered that action. This rule again uses the \emph{happens\_before} function to check that that the triggering message is received before the triggered message is sent. 

\paragraph{all\_ids\_in\_range}
The all\_ids\_in\_range rule enforces the size of the system. It defines the allowable values for IDs in source and destination fields. All source fields must be a integer greater or equal to 0 and less then the size of the system. All destination fields can be up to one ID beyond the limit to allow for wrapping. This allows for destinations to be integers greater or equal to -1 and greater or equal to the size. However, messages received from the referee never wrap so they have the same rules as source fields. This property is necessary to identify and discriminate some invalid cases in some Lemmas. 

\paragraph{promise\_forward\_commit\_backward}
The promise\_forward\_commit\_backward rule enforces that promise messages are sent only to successors in the cycle, while commit messages are sent only to predecessors in the cycle. This rule also enforces that if a message wraps around the destination id must be greater then the size or less than 0 rather than using the equivalent id within range. This allows for wrapping messages to easily be identified and preserves monotonicity.

\paragraph{phase\_sequence\_correct}
The MyCHIPs lift protocol operates in two distinct phases, the promise phase, and the commit phase. The phase\_sequence\_correct rule enforces that the originator initiates these phases with the Promise phase first and the commit phase second. This property helps to discriminate invalid situations in some Lemmas.

\paragraph{all\_ref\_receives\_causal}
The all\_ref\_receives\_causal rule is similar to all\_receives\_causal but is is connected with messages to and from the referee. Because there is no need for destination ids to wrap this property is easier to define and prove. 

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{splncs04}
\bibliography{krs_thesis}


\end{document}
\endinput
%%
%% End of file `sample-acmtog.tex'.
