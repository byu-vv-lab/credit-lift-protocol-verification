% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{bibnames}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{xcolor}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\newcommand{\originatorstate}{S_O}
\newcommand{\relayastate}{S_1}
\newcommand{\relaybstate}{S_2}
\newcommand{\refstate}{S_R}
\newcommand{\originatorsuccbal}{B^s_O}
\newcommand{\relayasuccbal}{B^s_1}
\newcommand{\relaybsuccbal}{B^s_2}
\newcommand{\originatorpredbal}{B^p_O}
\newcommand{\relayapredbal}{B^p_1}
\newcommand{\relaybpredbal}{B^p_2}
\newcommand{\nolift}{\emph{NO\_LIFT}}
\newcommand{\pend}{\emph{PEND}}
\newcommand{\call}{\emph{CALL}}
\newcommand{\void}{\emph{VOID}}
\newcommand{\good}{\emph{GOOD}}
\newcommand{\always}{\emph{always}}
\newcommand{\eventually}{\emph{eventually}}
\newcommand{\fair}{$F$}
\newcommand{\action}{\mathds{A}}
\newcommand{\listaction}{[\action]}
\newcommand{\promise}{\emph{promise}}
\newcommand{\commit}{\emph{commit}}
\newcommand{\happensbefore}{\prec_A}
\newcommand{\actsvalid}[2]{\mathds{V}(#1, #2)}
\newcommand{\projectsize}[2]{\mathds{P}(#1, #2)}

\newcommand{\hra}[2]{\emph{has\_required\_actions}(#1, #2)}
\newcommand{\hndr}[1]{\emph{has\_no\_duplicate\_receives}(#1)}
\newcommand{\allrc}[2]{\emph{all\_receives\_causal}(#1, #2)}


\newif\ifcomments
\commentstrue
\newcommand{\egm}[1]{\ifcomments\textcolor{orange}{egm: #1}\fi}


\begin{document}
%
%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Utilizing Model Checking to Support Constructive Proofs
of Distributed Cryptocurrency Protocols}
\titlerunning{Combining Model Checking and Constructive Proofs}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Kyle Storey}
\institute{Brigham Young University, Provo UT 84602, USA}
\email{kyle.r.storey@gmail.com}\\


%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

Model checking is an effective method to verify both safety and liveness properties in distributed systems. However, the complexity of model checking grows exponentially with the number of entities which makes it suitable only for small systems.
Interactive theorem provers allow for machine-verified proofs. These proofs can include inductive reasoning which allows them to reason about an arbitrarily large number of entities. However, proving safety and liveness properties in these proofs can be difficult.
This work explores how combining model checking and constructive proofs can be an effective method for formally verifying complex distributed protocols. This is demonstrated on a part of MyCHIPs, a novel digital currency based on the value of personal credit\cite{bateman_myCHIPs}. It has been selected as a case study because it requires certain properties to hold on a non-trivial distributed algorithm. 

\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}
%\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Model checking, interactive theorem provers, formal verification, distributed systems, digital currency}

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{chap:introduction}
This work combines model checking with theorem provers to verify safety and liveness properties in arbitrarily large distributed systems.
It uses a \emph{white box} approach for the model checking, which utilizes information about the internal state of each entity to verify certain properties hold.
It uses a \emph{black box} approach in the theorem prover, where only the inputs and outputs of each entity are considered.
If the set of observed inputs and outputs of each entity is unchanged as the system grows larger, then the set of internal states of each entity is unchanged.
When the set of inputs and outputs remains unchanged we say that the larger system \emph{conforms} to the smaller system \cite{dill_trace_theory}. This implies that the safety and liveness properties verified in the model checker continue to hold as the system grows large.

This process is demonstrated in a case study of MyCHIPs. MyCHIPs employs a distributed protocol as a means of facilitating the trade of goods and services between trusting partners. There are many temporal properties that must hold for MyCHIPs to meet its security and functionality requirements. This work verifies several of those properties.

In particular, this work verifies a distributed algorithm in the MyCHIPs system called a \emph{credit lift}. A \emph{credit lift} (\emph{lift} for brevity) in the MyCHIPs protocol operates on a group of agents arranged in a cycle such that each agent is in debt to its sucessor in the cycle. The protocol aranges for each to forgive their predecessor's debt, and in exchange, their own debt is forgiven. This protocol is critical for the MyCHIPs system to work correctly as a digital currency. Details of how this protocol fits in the larger system can be found in the appendix \ref{apdx:mychips}.

The debt clearing is done in two stages. First, each entity \emph{promises} to send CHIPs to their predecessor. Then, once all have promised, each entity \emph{commits} and sends CHIPs as promised. Once all have sent CHIPs, each entity's \emph{balance}--the difference between the number of sent CHIPs and the number of received CHIPs--remains the same, but they have cleared their liabilities. 

Unfortunately, sometimes entities on the MyCHIPs network may lose connectivity or otherwise become \emph{inactive}. An inactive node may not send or receive messages for an unbounded amount of time. It is not acceptable for lifts to hang in an unfinished state indefinitely. To prevent this, each lift is given a time limit, represented by a timestamp at which time the lift can no longer be committed. Because we don't expect entities on the network to have synchronized clocks, a referee is appointed whose clock is considered authoritative and acts as a consensus object. If the originator requests to commit before the timeout, the referee provides a digital signature that is proof that the lift has been committed. If the lift is not committed before the timeout, the lift becomes \emph{nullified} and the referee will digitally sign a statement that the lift has been nullified.

\subsection{Required Properties for MyCHIPs Correctness}\label{sec:requiredProperties}

MyCHIPS claims certain properties hold for its lift protocol but makes no formal arguments to prove those claims. This work formally proves some of those properties. These properties must hold for all compliant nodes on the network and must hold regardless of the number of nodes that participate in a lift. 

The properties this work will verify are as follows:

\begin{enumerate}
\item Eventually, every active node agrees that the lift was committed or every active node agrees the lift was nullified. 
\item The balance of every active node on the final state of the lift is equal to or greater than its initial balance.
\item Every active pair of nodes on the final state of the lift agree on their shared tally.
\end{enumerate}

Using a model checker, this work proves these properties hold in a system with just one originator---the node that initates the lift algorithm---one referee, and two relay nodes---nodes that participate in the lift that are not the originator or a referee. This work also defines a set of rules about a trace of events based on the constraints of the protocol. These rules can be used to determine if a trace of events is allowed by the protocol for a system of a given size. 
Then in the proof assistant Coq, we define the set of traces of events that are allowed by these rules. This is designed to enumerate the same set of traces checked by our model checker. This set of traces acts as an expression context as described by Dill \cite{dill_trace_theory} to define a conformation relation. If one subsystem conforms to another, it can be substituted without affecting the rest of the system's behavior. 
Using the model checking results as a base case, we prove that the set of traces produced by a chain of $n+1$ relay nodes conforms to the set of traces produced by $n$ relay nodes and inductively argue that the properties verified by model checking hold for any number of nodes.

\section{MyCHIPs protocol}
This section formally defines the MyCHIPs protocol, identifies the critical processes that require verification, and introduces the methods used to verify those processes.

\subsection{Credit Lift Algorithm}\label{sec:liftAlgorithm}
The MyCHIPs credit lift protocol described in Appendix \ref{apdx:coq_detail}, consists of three phases: discovery, promise, and commit. In the discovery phase, a circuit is identified where each entity is willing to participate in a lift. The correctness of the discovery phase is not critical because no transfer of value occurs during this phase. As such, this phase will not be verified.
Fig. \ref{fig:liftSequence} describes an example of a sequence of messages that would be passed in a typical lift during the promise and commit phases.

The originator initiates the lift by sending Relay 1 a lift record
$r = \langle id, value, ref, timeout\rangle.$ This record has a unique identifier, the lift value, the network ID of a referee that the originator selects, and a timeout timestamp. Sending this lift record represents a \promise and once Relay 1 obtains the referee's signature they can immediately add the number of chips specified in the lift record to its tally with the originator.

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{SequenceDiagramLifeline.png}
    \caption{Lift Protocol Sequence Example}
    \label{fig:liftSequence}
\end{figure}

When Relay 1 receives the lift record, it first confirms that it trusts the referee to be fair and available, and it confirms that the timeout timestamp is acceptable. If the referee is not trusted, or the known route to the target is no longer valid (for instance if it was used in a different lift and the node no longer has debt on that route to clear) it may choose to not continue. The node can optionally return a message indicating that it does not intend to complete the lift, or the node can simply ignore the message and wait for the lift to timeout. In the model used for verification, nodes ignore messages if they do not intend to participate in a lift. In our example, Relay 1 wishes to participate, so it forwards the lift record along with its own promise to Relay 2. Relay 2 then similarly evaluates the lift and decides to forward a promise to its predecessor which happens to be the originator. 

When the originator receives the promise from Relay 2, the lift moves into the commit phase and the originator sends the lift record to the referee to request a signature to commit. 

When the referee receives a lift record with a request to commit, it checks its clock to see if it received the commit message before the timeout. If it received the commit message after timeout, the Referee signs a statement nullifying the lift. If it received the commit message before the timeout, the referee signs the lift record and returns its signature to the originator. In either case, it records its result to provide to any node that requests the status of the lift. In the sequence diagram in Fig. \ref{fig:liftSequence}, the referee decides the commit message was received in time and sends the originator its signature.

When the originator receives the signature, it sends it to its successor in the circuit (Relay 2). Whenever a node in the circuit receives the signature, immediately the CHIPs it promised to its successor are valid. (i.e. it has forgiven the debt of its successor). 
To recover this value, it sends the signature to its predecessor.

In the sequence shown in Fig. \ref{fig:liftSequence}, once Relay 2 receives the signature, it experiences a long delay. Because of this delay, Relay 1 determines the lift is taking longer than expected and sends a message to the Referee to check the status of the lift. When the referee receives the status request, it checks its records and recalls the signature it previously provided to the originator. Because the lift is committed, the referee provides this signature to Relay 1. When a node receives a signature from the Referee instead of its predecessor it should not forward this signature. This ensures there is exactly one failure point in the cycle after which every node must obtain the lift status from the referee. This property is useful in proving the correctness of the protocol. However, eventually, Relay 1 receives the signature from Relay 2 which allows it to forward the signature. If the message sent by Relay 2 had arrived sooner, Relay 1 would not have needed to request the status from the Referee. Once the originator receives the signature from Relay 1, all nodes have received exactly the amount of CHIPs they have given and the lift is complete.

Note that the protocol makes a distinction between three roles nodes can take: originator, referee, or relay. In every lift, there is always exactly one originator, and exactly one referee, and there can be any number of relay nodes. These roles determine the types of actions a node can take and therefore define distinct equivalence classes to consider. 

\begin{figure}
    \centering
    \includegraphics[scale=0.44]{LiftStatesSeperate.png}
    \caption{Lift States Diagram}
    \label{fig:liftStates}
\end{figure}

Fig. \ref{fig:liftStates} describes the behavior expected from each of these equivalence classes as mealy machines.
These mealy machines are based on the state machines Bateman provides to define the protocol. \cite{bateman_state_machines} 
In the figure, each box represents the state of the lift from the perspective of the node, and each arrow represents a change in state and an associated action that is taken during the transition from one state to the next. Each transition is labeled with a condition that must be true for the transition to be taken, separated by a $/$ from an action that is taken during the transition. Each node has stored: the network ID of its predecessor (Pred), its successor (Succ), and the Referee. A transition can be made conditional on receiving a particular message from a particular network ID. This case is written in the form \emph{sender} $?$ \emph{message\_type}. As an action during a transition, nodes may transmit a particular message to a particular network ID. This case is written in the form \emph{recipient} $!$ \emph{message\_type}. 

The Spin model used as the model checking system is based on the mealy machine in Fig. \ref{fig:liftStates}. The details of that implementation are described in Section \ref{chap:model_checking_results}. The set of rules for the proof in Coq are defined based on the mealy machine in Fig. \ref{fig:liftStates} and the sequence diagram in \ref{fig:liftSequence}. Details of that implementation are described in Section \ref{chap:coq_results}.


\section{Model Checking Results} \label{chap:model_checking_results}
The safety and liveness properties required for the MyCHIPs lift protocol can be proven by an exhaustive search all possible states in a small system. Spin is a powerful model-checking tool that allows for these types of properties to be expressed and verified. There are three important pieces to this verification: The State machines of each node in the system, the message passing between these nodes, and the definition of the properties we are asking Spin to verify. 

\subsection{Implementation of Node State Machines} 
To implement the protocol as described by the mealy machine above we need to implement three process types: Originator, Relay, and Referee. They each are implemented using similar techniques. The source code for the spin model can be found on the \emph{GotChoices} github repository \cite{bateman_myCHIPs}. 


\subsection{Implementation of Message Passing}
\subsubsection{Channels}
The message passing between nodes is modeled by creating 3 message channels for each node. One for messages received from the node's successor in the cycle, one for messages from the predecessor and one for messages from the referee. The referee also has a channel where it receives messages.
\subsubsection{Message Types}
The details of the message are not important for the model, instead, each message will have a specific type. It is expected that nodes in a real system will verify that messages are valid as part of processing a received message. For the model, we will consider invalid messages as if they were never received. Once a valid message is received, the type of that message will inform the actions a node will take in response to the message. Examining the state machines we can see that knowing the messages type is sufficient for our model. 
\subsubsection{Message Loss}
Rather than using the channels directly, the state machines for each node use helper functions to send messages. These helper functions determine which node the message should be sent to and puts the message in the appropriate channel. These helper functions also model the possibility that a message might be lost in transit. This is done using the \emph{if} keyword. Similar to the \emph{do} keyword each statement in an \emph{if} block is a non-deterministic choice. Whenever a message is sent, Spin models it as a non-deterministic choice on whether the message should be placed in the appropriate message queue or dropped. Algorithm \ref{spin:messages} shows this implementation. In its model checking, Spin will evaluate all combinations of lost messages. One unique case is the possibility that all messages from a given node are dropped. This models the case where a node crashed or otherwise lost connection to the network. 

The protocol defines that the referee should be a node that is consistently available so messages to and from the referee are never dropped. This is required to prove the some of the required liveness properties. Without this reqirement the problem is isomorphic with the \emph{two generals problem}, and it is imposible to guarantee eventual concensus on the lift status. This requirement enforces that eventually every message sent to and from the referee will be received, however the model will evaluate the possibilities that arise should those messages take a very long time. 

\subsubsection{Modeling Time}
Because we don't expect nodes to have synchronized clocks, modeling time for each node becomes extremely computationally complex. Rather than modeling time explicitly, we allow all decisions that would be made by a node based on time to be a non-deterministic choice. This allows the model to explore all combinations of time-drift and all behavior that could arise without the need to model time. Leaving out time reduces the state space considerably and makes the analysis computationally feasible. 

\subsection{Chits and Tallies}
Because a Token in the MyCHIPs is only valid between exactly two entities, these tokens only need to be tracked by those two entities. These tokens are tracked on a consensed record called a \emph{Tally}. A \emph{Chit} is an atomic transaction where one or more CHIPs are given to the partner. A Tally is an ordered collection of Chits with additional information to note the terms of the two entities agreement. 

Whenever a pair of entities desires to establish a trade relationship with each other, they create a new Tally to track that relationship. Most trade relationships are fairly consistent about who is selling goods or services and who is buying. When creating a Tally the entities establish this normal flow by assigning the entity who is usually paid and provides goods the \emph{Stock} role in the Tally, and the one who usually pays the \emph{Foil} role. These names hearken to a traditional method of tracking such credit relationships called a \emph{Split Tally}. If the entity that takes the \emph{Stock} role wishes to purchase goods or services from the \emph{Foil} entity, the entities create a new Tally with the roles reversed.

Each time a transaction is made, the entity with the Foil role creates a Chit that includes: 
\begin{enumerate}
    \item The number of CHIPs being sent
    \item A verifying digital signature
    \item The date and time of the transaction
    \item Other metadata about the transaction
\end{enumerate}
The verifying signature could be either the signature of the entity with the Foil role, or as described in section \ref{sec:liftAlgorithm} the signature of the referee if the transaction is part of a credit lift. The verifying signature is all that is needed for one entity to prove the other owes some debt, however, it is helpful for both entities to have assurances that they are in agreement about the balance of their tally. 

To ensure that both entities agree on the state of the Tally, they exchange hashes of their Tally. If the hashes match they can be assured they are in agreement on both the Chits in the tally as well as the order of those Chits. If there is a mismatch, the consensus algorithm is simple: the Tally of the entity with the Foil role is considered correct. If there are still missing Chits, the entity with the Stock re-transmits those to the Foil. The Foil adds those Chits to the Tally and re-transmits its new hash. 

\begin{algorithm}
\caption{Promela implementation of Message Passing} \label{spin:messages}
\begin{verbatim}
chan succ[N_NODES] = [10] of { mtype }
chan pred[N_NODES] = [10] of { mtype }
chan ref[N_NODES] = [10] of { mtype }
chan to_referee = [10] of { mtype, chan }
mtype = {promise, status, pend, commit, void, signature}

inline sendToPred(message, id) {
    //TODO: make some messages fail
    if
    :: true ->
        printf("%d Sending %e to Pred\n", id, message)
        byte prev;
        prev = (id+N_NODES-1)%N_NODES; //find who it goes to
        succ[prev]!message; //put it in their succ box (if they are my pred I am their succ)
    :: true ->
        printf("%d Message to Pred Failed\n", id)
    fi
}

inline sendToSucc(message, id) {
    if
    :: true -> //Ssend the message
        printf("%d Sending %e to Succ\n", id, message)
        byte next;
        next = (id+1)%N_NODES; //find who it goes to
        pred[next]!message; //put it in their pred box (if they are my succ I am their pred)
    :: true -> //The message Failed to send
        printf("%d Message to Succ Failed\n", id)
    fi
}

inline sendToReferee(message, id) {
    printf("%d Sending %e to Ref\n", id, message)
    to_referee!message(ref[id]); //put it in the referee's in box with a return channel for the response
}
\end{verbatim}
\end{algorithm}

\subsection{Implementation of Properties}
Algorithm \ref{spin:properties} shows the implementation of each property.

It begins with a fairness property that is required as a consequence for not explicitly modeling time. Because the referee must decide if a lift should be committed or nullified based on a timeout, when a node requests the status of a lift the referee may return a \good or \void message or they may send a \emph{PEND} message if the timeout has not been reached yet and the lift is not yet committed. However, because this decision is modeled as a non-deterministic choice, the model considers the possibility that referee will always send a pend message in an endless loop with one of the nodes. Spin identifies this case and provides it as a counter example for many of the properties. However, no matter how far into the future the timeout was set,eventually the timeout will expire. So that counter example is infeasible and not interesting for us. 

To tell Spin this is a case we are not interested in we define a fairness property that says that eventually the Referee is either in the \good or the \void state. However, when introducing a fairness constraint it is important to verify that that constraint can be met. If that constraint can not be met the properties will be \emph{vaccuously true}. Because of this we need to add a new property to verify that the constraint is met in at least 1 (and likely almost all) cases. This would normally take the form of an existential property. Unfortunately, Spin does not perform well to prove existentials so instead we create a property that says that it is never true that the fairness property is met. We expect this property to fail. If it does it means that there are cases where the fairness property holds.

Then we write all our properties such that we claim only that if our fairness property holds does our desired property hold. This effectively trims out that infeasible case and allows Spin to continue and verify the remaining properties. 

The properties p1, p2, p3 and p4 all map to the respective properties described in section \ref{sec:requiredProperties}. 

Linear time temporal logic (ltl) properties are constructed inductively in spin. An ltl property is the \emph{ltl} keyword followed by either annother ltl property, or a proposition which---in the case of the properties used in this analysis---is just a Boolean expression. For instance, a proposition might be $state[ORIGINATOR] == GOOD$ which is true when the originator is in the \good state and false otherwise. The \emph{always} ltl keyword constructs a property that holds only if for every system snapshot encountered the property following holds. For example, $always~state[RELAY] == VOID$ holds only if the state of the relay is \void in each and every state. 

%TODO Consider putting a grammar diagram for ltl properties here

The \emph{eventually} ltl keyword holds if for all paths through the system state space there exists a system snapshot where the property following holds. If there exists a single path where the property never holds the eventually ltl property does not hold. That single path may be a path to a termination state, or it could just be a cycle of states. 

The composition \emph{always eventually} is used to make claims about the final state of the system. Using the \emph{eventually} construct alone will accept a trace where a condition holds for a moment but doesn't hold later in the trace. Using \emph{always eventually} ensures that the conditional holds at all final states of the system (or any loop of non-final states). 

The purpose of p1 is to verify that lifts always eventually are committed or nullified for every active node. Put differently nodes are not left hanging with an incomplete lift forever. 
When a lift at a node is committed it moves the lift into the \good state. When a lift at a node is nullified it moves the lift into the \void state. If the state is either \good or \void then the lift is in a final state. In the model there are 4 nodes: the originator, two relay nodes, and the referee. For each of these nodes we need to check that in all possible scenarios they eventually are all in a final state. Using the always eventually ltl construct we check that the originator, the two relays, and the referee are all in the final state. 

The purpose of p2 is to verify that at the final state of the lift, every active node agrees that the lift was committed or every active node agrees the lift was nullified. We again use the always eventually construct to ensure this property holds at the final state of the system. To check that all nodes are in agreement on the state of the lift we check to ensure that The originator's state is equal to the first relay's state, the first relay's state is equal to the second relay's state, and that the second relay's state is equal to the referee's state. Which implies by transitivity that all nodes have the same final state. If this Boolean expression is true at the final state then all nodes are in agreement on the final state of the lift.

The purpose of p3 is to verify that the balance of every active node on the final state of the lift is equal to or greater than its initial balance. Because the starting balance is not needed to implement the model we record the change in a nodes balance with its partners rather then it's total balance. The model tracks the change in balance of a node with it's successor in \emph{balanceSuccDelta}, and it's predecessor in \emph{balancePredDelta}. In a successful lift, we expect the sum of these balances to be zero. However, if a node fails and stop transmitting, their successor might obtain the signature from the referee. When it does so it can use it to collect chips from it's succssor without needing to send chips to it's predecessor. This is an allowable result so we allow the sum of the change in balances to be greater then zero to allow for this case.

In p3 we verify that each node's balance is equal greater then their starting balance. Again we make use of the always eventually construct to ensure that this condition holds at the final state of the system.

p4 ensures that always eventually every pair of nodes agrees on the change in balance between them. 

\subsection{Definition of the system state}\label{sec:statedef}
The system state is composed of the individual state for each node. The state for the originator and each relay node can be represented as:
$$Node~state \equiv \langle S, B^s, B^p \rangle$$
$$
S \in \{\nolift, \pend, \call, \void, \good\}
$$
$$
B^s, B^p \in \mathds{Z}
$$
Here $S$ represents the mealy machine state and $B^s$ and $B^p$ represent the change in balance with the node's successor or predecessor respectively.
There are additional constructs used to pass messages from one node to another which are important to the implementation but are not used in the verified properties. A formal definition of these constructs is omitted. 

The state of the referee is similar except that it omits the balances
$$Referee~state \equiv \langle S \rangle$$

When composed together as a system state:
$$System~state \equiv \langle S_O, S_1, S_2, S_R, B^s_O, B^p_O, B^s_1, B^p_1, B^s_2, B^p_2  \rangle$$

With the $O$ subscript representing the \emph{originator}, $1$ and $2$ representing the first and second \emph{relay} nodes, and $R$ representing the \emph{referee}.

\subsection{Definition of the properties}
The desired properties are defined in terms of the simplified state presented in section \ref{sec:statedef}:

\begin{multline*}
    F \equiv \eventually \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}

\begin{multline*}
    P_1 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorstate = \good \vee \originatorstate = \void) \wedge \\
     (\relayastate = \good \vee \relayastate = \void) \wedge \\
     (\relaybstate = \good \vee \relaybstate = \void) \wedge \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}
    
\begin{multline*}
P_2 \equiv \always\ \eventually,\ \\
    (\originatorstate = \relayastate = \relaybstate = \refstate) \\
\end{multline*}
\begin{multline*}
P_3 \equiv \always\ \eventually,\ \\
    (\originatorsuccbal + \originatorpredbal \ge 0) \wedge
    (\relayasuccbal + \relayapredbal \ge 0) \wedge
    (\relaybsuccbal + \relaybpredbal \ge 0) \\
\end{multline*}

\begin{multline*}
P_4 \equiv \always\ \eventually,\ \\
    (\originatorsuccbal = \relayapredbal) \wedge
    (\relayasuccbal = \relaybpredbal) \wedge
    (\relaybsuccbal = \originatorpredbal) \\
\end{multline*}

\subsection{Results}

To verify each of these properties, Spin evaluated 
577244 unique states with 240285 edges between those states. Evaluating each property spin found that there were no counter examples that both satisfied the fairness property and violated one of the properties. We also verified that the fairness property is satisfied in some (presumably all but very few) cases. 

From these results, we can conclude that the properties hold for a system with one originator, two relay nodes, and one referee, for all possible orderings and types of messages sent and for all combinations of messages failing to be delivered.

\section{Constructive Proof} \label{chap:coq_results}

Coq is a popular interactive theorem prover that can be used to define and prove properties. Inductive reasoning techniques can be used in Coq to state and prove properties of arbitrarily large systems. This work implements a proof that shows that all possible traces that satisfy the validity rules for a system of arbitrary size $n$ can be \emph{projected} to a system of size $3$ without changing the inputs or outputs of those 3 nodes. Because the inputs and outputs are unchanged we can say that the larger system conforms to the smaller system. This implies that the behavior is unchanged and thus the desired properties proven by the model checking as described in Section \ref{chap:model_checking_results} continue to hold for an arbitrarily large system.
The details of the implementation can be 
found on the \emph{GotChoices} github repository \cite{bateman_myCHIPs}. 

\subsection{Definitions} \label{sec:definitions}
The MyCHIPs system in the Coq proof is written with a \emph{black box} approach. The Coq proof does not need to know anything about the internal state of each of the nodes. To prove that a larger system conforms to a smaller system we need only show that the inputs and outputs of each node are equivilant regardless of the size of the system. Because of this many of the variables in the Spin model, including the current balance, and each nodes lift state are omited from the Coq definitions. 

Rather than considering each individual node in the system, the Coq proof operates on traces of actions that might occur in the system. Each trace is represented with an ordered list of \emph{Actions}. The list represents the actions that each node took in the system in the order that they took them.

We define rules that must hold for a trace of actions to be considered valid. We define these rules such that all possible traces of actions in the system are considered valid, and all impossible traces are considered invalid. These rules include properties that are enforced by the MyCHIPs protocol as well as properties that are intrinsic to a distributed system. For example, we enforce  messages can only be received after the message has been sent.

We define four distinct kinds of actions: \emph{Send}, \emph{Receive}, \emph{SendRef}, and \emph{ReceiveRef}.
There are also two explicit types of messages, \promise and \commit, as well as one implicit message type that is status request messages exchanged with the referee.
If a node requests the status from the referee but that referee responds with a \emph{PEND} response, those actions do not affect node state so are omitted from the Coq action trace.

Each node in the system has a unique id represented by an integer. The Originator's id is 0, with all other nodes in the system having some id greater then 0.

\subsubsection{Send Actions}
Each \emph{Send} action has 3 parameters: a source, a destination, and a message. The source is an integer that is the id of the node sending the message. The destination is an integer that is the id of the node that may receive the message. The message a type that is either \promise or \commit.

\subsubsection{Receive Actions}
Each \emph{Receive} action has 2 parameters: a destination, and a message. The destination is an integer that is the id of the node that is receiving the message. The identifier of the node that sent the message is unimportant for evaluating inputs and outputs of nodes, and omitting it simplifies projection. The message is again either \promise or \commit.

\subsubsection{SendRef Actions}
Each \emph{SendRef} action has 1 parameter: the source id. The destination and the message type are implicit. The destination is the \emph{Referee} and the message type is a status request. 

\subsubsection{ReceiveRef Actions}
Each \emph{ReceiveRef} action has 1 parameter: the destination ID. The source and the message type are again implicit. The source is the \emph{Referee} and the message type is a Commit type message.

\subsubsection{Validity Rules} \label{sec:validity_rules}
The rules that determine if a trace of actions is valid are defined in \emph{acts\_valid}. There are 8 rules:

\begin{enumerate}
  \itemsep 0pt
  \item \emph{has\_required\_actions}
  \item \emph{has\_no\_duplicate\_receives}
  \item \emph{all\_receives\_causal}
  \item \emph{all\_sends\_triggered}
  \item \emph{all\_ids\_in\_range acts}
  \item \emph{promise\_forward\_commit\_backward}
  \item \emph{phase\_sequence\_correct}
  \item \emph{all\_ref\_receives\_causal}
\end{enumerate}

All must hold for a trace of actions to be considered valid. The rules were designed to exactly match the possible traces that could be generated by a system of nodes for the given size. Each of these rules are defined formally below and described in detail in Appendix \ref{apdx:coq_detail}.

For the following definitions, we define an action type 
$$\action \in \{(Send, s, d, m), (Receive, d, m), (SendRef, s) (ReceiveRef, d)\}$$
with source identifier $s \in \mathds{Z}$, destination identifier $d \in \mathds{Z}$, and a message $m \in \{Promise, Commit\}$. We also define a trace of actions 
$A \in (a_1, a_2, ... a_n), a_i \in \action,$ as well as a size $S \in \mathds{N}, S = n.$

\paragraph{has\_required\_actions} The trace contains the required Sends and Receives with Promise Messages, and nodes before a given failure point $m$ have the required Sends and Receives with Commit messages, or if they are after a given failure point they request the lift status from the referee.

$$
   \forall n \in \mathds{N}, n + 1 < S \longrightarrow \\
   (Send, n, n+1, Promise) \in A \wedge (Receive, n, Promise) \in A\ \\
$$
$$ \wedge \\ $$
$$
   \exists m \in \mathds{N}, \forall n \in \mathds{N}, \\
$$
$$
   (n \ge m) \longrightarrow (n + 1 < S) \longrightarrow \\
   (Send, n+1, n, Commit) \in A \wedge (Receive, n, Commit) \in A\ \\
$$
$$ \wedge \\ $$
$$
   (n < m) \longrightarrow (n < S) \longrightarrow \\
   (SendRef, n) \in A \wedge (ReceiveRef, n) \in A\ \\
$$
$$ \wedge \\ $$
$$
    (Send, 0, -1, Commit) \in A \\
$$

\paragraph{has\_no\_duplicate\_receives}
The trace contains at most one of each receive action. 
$Given\ r = (Receive, d, m), n \in \mathds{N}, m \in \emph{Message},\ \sum_{A}[x=r] \le 1$. Which counts the number of occurrences where $x=r$ in $A$. 
\paragraph{all\_receives\_causal} Every Receive action is preceded by a Send action where a message of that type is sent to the destination. Given $r = (Receive, d, m), r \in A \longrightarrow \exists a = (Send, s, d^*, m), a \in A \wedge d^* = d \mod S \wedge a \happensbefore r.$ Where $\happensbefore$ is the happens-before relation over $A$, indicating that $a$ occurs before $r$ in the trace of events. $isSendForReceive(a, r) eval$
\paragraph{all\_sends\_triggered} Only the originator sends a message without first receiving a message of the same type. 
Given $a = (Send s, d, m), s \neq 0 \longrightarrow a \in A \longrightarrow \exists r, r = (Receive, s, m) \wedge r \in A \wedge r \happensbefore a$
\paragraph{all\_ids\_in\_range} Ensures the trace only includes identifiers for nodes that are in a system of the given size. Destinations of a send are allowed to \emph{wrap} by one identifier. Given $a \in \action, a = (Send, s, d, m) \longrightarrow 0 \le s < \S \wedge -1 \le d \le S$
\paragraph{promise\_forward\_commit\_backward} All Promise messages are sent to the successor in the cycle and all Receive messages are sent to the predecessor. Given $a = (Send, s, d, m), a \in A \longrightarrow [(m = Promise \longrightarrow d = s + 1) \wedge (m = Commit \longrightarrow s = d + 1)]$
\paragraph{phase\_sequence\_correct} The originator sends the first Commit message, and the originator is the last to receive each type of message. Given $a, b \in A$,
$$ 
a = (Send, 0, -1, Commit) \longrightarrow 
$$
$$
[
(b = (*, s, d, Commit) \wedge (s \neq 0 \vee d \neq -1) \longrightarrow a \happensbefore b)
\wedge 
(b = (Send, s, d, Promise) \longrightarrow b \happensbefore a)
]
$$
$$
a = (Receive, 0, m) \longrightarrow 
$$
$$
[
b = (Send, s, d, m) \longrightarrow b \happensbefore a
]
$$
\paragraph{all\_ref\_receives\_causal} No nodes receive a message from the referee before they have sent a message to the referee. Given $r = (ReceiveRef, d), r \in A \longrightarrow \exists a = (SendRef, d), a \in A \wedge a \happensbefore r$

\subsection{Projection}
Projection is defined with the \emph{projected} function. Given the size of the system we would like to project onto and an action, the \emph{projected} function returns an option Action. An option is a Coq construct that allows for a returned value to be optional. An option is either None, or Some followed by the result. We use this option construct to signal when a action should be kept in the projected system and when an action should be omitted. 

A Send action is omitted in the projection if the source is greater or equal to the new size, or if the destination is strictly greater then the new size. A Receive is omitted in the projection if the destination is greater or equal to the new size. SendRef and ReceiveRef messages are omitted if the source or destination is greater or equal to the new size.  

The type of the projected function would allow mutations of actions if neccessary. Early attempts at the proof mutated actions to \emph{wrap} a sent message around to $0$ or $size-1$ when the destination was projected out. However, allowing actions to mutate as part of the projection increased the complexity of the proof. Using the modulo arithmatic construct to handle wrapping provides a more robust mathimatical foundation. In the final proof the projeciton never mutates actions only omits them if necessary. 

\subsubsection{project\_to\_size} 
Given a size and a list of actions, \emph{project\_to\_size} returns a new list of actions that omits all actions for which \emph{projected} returns None. 

\subsubsection{is\_send\_for\_receive}
This defines what a \emph{Send} action must look like in order for it to be considered to be the \emph{Send} that corresponds with a given \emph{Receive}. The way this is defined is a core insight that enables a proof of the conformance property. 

A \emph{Send} corresponds with a receive if the destination ID for the \emph{Send} is equal to the destination ID of the \emph{Receive}, \begin{bf}modulo the size\end{bf}.
$$src~\%~size = dest~\%~size$$
Because we allow the destination of a \emph{Send} to be an integer between $-1$ and the size \emph{inclusive} this means that a node can send to ID $-1$ and this always corresponds with the node with the maximum ID in the system. Also in the original system a node might send a message to the node with ID $n$, but when we project to size $n$ the node with ID $n$ is removed from the system. This send---instead of being sent to a node that doesn't exist---now gets mapped to node $0$ because of how \emph{is\_send\_for\_receive} is defined. This allows for the projection to work without the need to mutate actions, which makes proving properties about the projected system much simpler.  

\subsection{Proofs}

The main theorem proven in the coq script is called \emph{all\_valid\_systems\_conform\_to\_size\_3}. This theorm states the conformance property we must prove to show that our Spin results extend to an arbitrarly large number of nodes. It is difined using \emph{acts\_valid} which is the validity rules described in Section \ref{sec:validity_rules} defines a set of rule that must hold for a list of actions to be considered valid. The definition of \emph{all\_valid\_systems\_conform\_to\_size\_3} also uses \emph{project\_to\_size} which is a function that defines how projections are pefromed. Detailed descriptions of the \emph{acts\_valid} and \emph{project\_to\_size} were provided in seciton \ref{sec:definitions} above.

This main theorem is is proven by induction on $n$: the size of the original system. It begins by eliminating cases where the system size is smaller or equal to 3, then uses a lemma \emph{larger\_conforms\_to\_smaller} to prove it holds for the system of size 4. We then use the lemma \emph{projected\_larger\_conforms\_to\_smaller} which is similar to \emph{larger\_conforms\_to\_smaller} except that it operates on a system that has already been projected. This allows us to reduce the size of the original system by one at a time until we reach the 4 node base case which was proven previously.  In this way these lemmas can be used to execute an inductive step that proves the property. 

\emph{larger\_conforms\_to\_smaller} and \emph{projected\_larger\_conforms\_to\_smaller} in turn utilize several sublemmas that build on still other sublemmas. This stack of supporting lemmas is visualized in Figure \ref{fig:coqLemmaStack}. Each of these lemmas are described in detail below.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{CoqLemmaStack.png}
    \caption{Stack of Supporting Lemmas}
    \label{fig:coqLemmaStack}
\end{figure}

\subsubsection{all\_valid\_systems\_conform\_to\_size\_3}
$$\forall A \in \listaction\ \actsvalid{A}{n} \wedge n > 3 \longrightarrow \actsvalid{\projectsize{A}{3}}{3}.$$

\subsubsection{larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ \actsvalid{A}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$

The \emph{larger\_conforms\_to\_smaller} lemma proves that all systems of size $n+1$ conform to a system of size $n$. This lemma relies on sublemmas that prove that most of the validity rules are independent of projection. Meaning if the rule holds in a system they continue to hold when projected to a smaller system. The only exception is the \emph{all\_receives\_causal} rule which is not independent of projection. Instead, we use a lemma \emph{valid\_implies\_all\_receives\_causal\_in\_proj} which shows that any valid system still maintains the \emph{all\_receives\_causal} rule in the projected system. Details of those proofs are described later in this section. 


\subsubsection{projected\_larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ n \in \mathds{N}, \actsvalid{\projectsize{A}{n+1}}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$
This lemma is used as an intermediary step between the original large system and the projection down to size 3. It states that given a set of acts of some larger size $m$, if that larger system when projected to size $n+1$ is valid that implies that the system when projected to size $n$ is valid.

It makes use of a sublemma \emph{project\_idempotent} which proves that projecting to some size $n$ and then projecting to some smaller size $m$ is equivilant to projecting directly to the smaller size $m$. This combined with the lemmas proving the rules are independent of the projection used in \emph{larger\_conforms\_to\_smaller} prove this property.

\subsubsection{project\_idempotent}
$$\forall A \in \listaction\ n0\ n1 \in \mathds{N}, n0 < n1 \longrightarrow \projectsize{\projectsize{A}{n1}}{n0} = \projectsize{A}{n0}.$$
This lemma proves that projecting first to a larger size, $n$, then to a smaller size, $m$, is equivilant to projecting to size $m$ directly. This is proven directly through induction on the list of actions, and case analysis of each type of action. 

The intuition is that actions are removed when one of there parameters is smaller then the size. Because $n>m$ we know that if an action was omitted in the projection to size $n$ then it also is omitted in the projection to size $m$.  

\subsubsection{has\_required\_actions\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n < 2 \wedge \hra{A}{n+1} \longrightarrow \hra{\projectsize{A}{n}}{n} $$


This lemma proves that if a trace of actions has all the required actions for size $n+1$ that implies that when that trace of actions is projected to size $n$ it also has all the required actions. 

The intuition for this lemma is that the actions that are projected out are precisely the actions that are no longer required for the smaller system. The proof examines each type of action that is required and shows that action is also required in the larger system. This implies that the action exists in the original list. We then show that that action remains in the list after the projection using the sublemma \emph{in\_projection\_remains} which shows that if an action is in the list and the projection of that action is not \emph{None} then it remains in the projected list.

\subsubsection{has\_no\_duplicate\_receives\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n < 2 \wedge \hndr{A} \longrightarrow \hndr{\projectsize{A}{n}} $$
This lemma proves that if a trace of actions does not have more then one receive to the same destination of a given type that implies that when the list is projected to size $n$ it still has no duplicates.

This is proven by induction on the trace of actions, with the core intuition being that the projection can not introduce any new actions. This is proven in the sublemma \emph{not\_in\_orig\_not\_in\_proj}. This intuition is proven by showing that if it were the case that the projected trace of actions had a duplicate where the original trace did not this leads to a contradiction. 


\subsubsection{valid\_implies\_all\_receives\_causal\_in\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n < 2 \wedge \actsvalid{A}{n+1} \longrightarrow \allrc{\projectsize{A}{n}}{n} $$
This lemma is the least trivial and the core problem that needed to be proven to show that the larger system conforms to the smaller system. The receive causality property is difficult because an send action that is associated with a given receive prior to the projection may be removed in the projection. However, if the send for a receive is projected out there is an equivilant send from the previous node that now can be matched with that receive. 

This lemma is proven by careful case analysis. The proof itself spans nearly 500 lines and makes use information known about the trace of actions based on the \emph{acts\_valid} assumption. 

The \emph{all\_receives\_causal} property asserts that for all possible actions, if that action is a receive and it is in the trace of actions that implies that there must exist an action that is the associated send for that rceive, that send must be in the trace, and that send must happen before the receive. 

We begin by introducing an action $r$ which is the receive in question. We assume it exists in the projected list and that it is indead a receive and use the sublemma \emph{in\_proj\_in\_orig} to show that the action must also appear in the original trace. 

With the knowledge that the action was in the original trace the assumption of the validity of the original trace allows us to show that there must be a corresponding send for that receive in the orignal trace. 

We now know that there is a recieve that is both in the original trace and in the projected trace, and that there is a corresponding send in the original trace. From here we examine the posible scenarios for what happens to the corresponding send in the projection.

These scenarios are:
\begin{enumerate}
\item \label{case:normal} Both are unchanged. Neither the send nor the receive are removed and neither \emph{wrap} around in the modulus.
\item \label{case:src_wrap} The send alone is projected out. The source of the send refers to a node that is no longer in the system the orignal send is projected out.
\item \label{case:dest_wrap} The send destination alone is projected out and the send now \emph{wraps}.
\item \label{case:both_wrap} Both the send source and the send destination refer to a node that is removed. 
\end{enumerate}


Scenario \ref{case:normal} if pretty streightforward, the send for the receive is the exact same send as in the original trace. We just show that the send remains in the projection.

Scenario \ref{case:src_wrap} is tricky. The previous associated send is projected out. But the recieve is not projected out. To prove this scenario we use information about the required actions in the original trace. After unpacking this information we can show that there must be a send that would have gone to the node that was projected out. We show that this send \emph{wraps} due to the change in the size in the modulus which means that that send is now associated with the receive in question.

Scenario \ref{case:dest_wrap} is the dual of scenario \ref{case:src_wrap}. The same problem but from the other perspective. This is the case where a node that is not projected out sends to a node that is projected out. We show that that message \emph{wraps} to connect with a new recieve which is our receive in question. %THIS EXPLAINATION FEELS OFF. DOUBLE CHECK THIS

Scenario \ref{case:both_wrap} is an interesting case because it is only possible if we project out more then one node in a single step. The way the property is defined this is not possible because we have a system that is valid for size $n+1$ that is projected to size $n$. It takes some mathematics and a few properties about modular arithmatic to show that this case is imposible and always leads to contradictions.

There is one final scenario in the proof not listed above. It is the case where the destenation of the receive is projected out. This comes out as an implementation detail for how we obtained some information about the original destination. We assumed that the original destination was either less then the new size or greater or equal to it. Then we checked each case. The case where the destination was greater or equal to the new size is easily dismissed by noting that that would mean that the recieve that needs a send was projected out, which is a contradicition with the assumption that it is in the projected trace.

Once each of these cases were individually proven or shown to lead to contradictions the property proves out.

\subsubsection{all\_sends\_triggered\_independent\_of\_proj}
This lemma shows that if \emph{all\_sends\_triggered} holds in the original system it continues to hold in the projected system. This property enforces a partial order of events.

The intuition of this proof is that projections don't affect the order of events. This is proven concretely in the sublemma \emph{happens\_before\_independent\_of\_proj} which us used several times in this proof. 

\subsubsection{all\_ids\_in\_range\_independent\_of\_proj}
This lemma proves that there are not any actions associated with nodes that would not be present in a system of the given size. It can be directly poven based on the definition of \emph{projected}. 

\subsubsection{promise\_forward\_commit\_backward\_independent\_of\_proj}
This property requires that the source and dest feilds in Send actions follow certain patterns. The intuition if this proof is that projection does not mutate fields. We simply show that the projected item must have been in the original list and this property holds on the action in the original list. Because it has not changed this property holds in the projected list.

\subsubsection{phase\_sequence\_correct\_independent\_of\_proj}
This property also imposes a partial order on traces. It is proven similar to \emph{all\_sends\_triggered\_independet\_of\_proj}, by showing that projections don't effect the order of events using the sublemma \emph{happens\_before\_independent\_of\_proj}. 

\subsubsection{all\_ref\_recieves\_causal\_independent\_of\_proj}
This property requires that if a node receives a message from the referee it first sent a message to the referee. The intuition of this proof is that if a SendRef action that requested the status from the referee is projected out that implies that the ReceiveRef action is also projected out.

\subsubsection{in\_projection\_remains}
This lemma shows that if \emph{projected} of an action for a given size is not \emph{None} then it is still in the list of projected actions and vise versa. It is proven by induction on the list of actions. The base case with an empty list easily leads to a contradiction. Then when considering a single action it follows from the definition of \emph{project\_to\_size} that if projected returns Some action that it is not removed from the list. 

\subsubsection{not\_in\_orig\_not\_in\_proj}
This lemma shows that if an action is not in the original trace of actions it cannot be in the projected trace of actions. It is proven by induction on the trace of actions. It uses a proof by contradiction. We assume that the action is not in the original list but is in the projection. Then using the sublemma \emph{in\_proj\_in\_orig}, we show that it must also be in the original list. This contradits our first assumption.

\subsubsection{in\_proj\_in\_orig}
This a trivial lemma based on \emph{in\_projection\_remains}. It exists for convinience to allow us to extract that an action must be in the original without needing to seperate that information from the fact that the action when projected is not \emph{None}. Perhaps the proof script should be refactored to remove this lemma for clarity.

\subsubsection{happens\_before\_independent\_of\_proj}
This is the core lemma showing that projection doesn't reorder actions in the trace. It is proven by induction on the trace of actions. The base case with an empty trace is easily dismissed with a proof by contradiction. 
Then when we consider a list of actions with one additional action prepended to the list. We call this new action $a$. On this new list we know that the action $x$ happens before the action $y$.
We can examine what might happen to $a$ in the projected trace.
Using the sublemma \emph{projected\_in\_or\_out} we know that an action either remains in the projected trace or is removed entirely from the projected trace.
We will consider both of these cases.
If $a$ remains in the list then it becomes the first item in the list. 
We then consider the possible cases for what $a$ is.
$a$ could be equal to $x$, it could be equal to $y$, or it could be neither $x$ nor $y$.
If it is equal to $x$ then because it is the first item in the list it must happen before $y$.
If it is equal to $y$ it means that $y$ must happen before $x$, however $a$ is also the start of the unprojected list so we can show that that is a contradition with our assumption that $x$ happens before $y$.
If it is either $x$ nor $y$ then it does not have any berring on whether $x$ happens before $y$ or not. We can then consider the rest of the list to check that $x$ happens before $y$ in the sublist. This reduces the problem down to our inductive hypothesis.
Finally we must consider the case where $a$ is removed from the list in the projection. This immediatly reduces to the inductive hypothisis which allows us to prove that the \emph{happens\_before} property is independent of projection.

\subsubsection{project\_in\_or\_out}
This lemma shows that for every action and every size, that projecting that action to that size it either remains in the trace of actions or it is removed from the trains of actions. Based on the definition of \emph{projected} we show that this maps to decidability of a few inequalities on integers (the IDs of the nodes involved in the action). The Coq standard library has proofs of decidability of inequalities on integers which are used to prove this lemma.

\section{Combining the Results}
With the results presented in Section \ref{chap:model_checking_results} and Section \ref{chap:coq_results} we have shown that the desired properties hold for a small system and that an arbitrarily large system can be projected to the smaller system without changing the inputs and outputs observed by each entity in the system. 
\egm{Make clear the entities that define the observed behavior that is preserved: originator, two relays, and a referee? Maybe even give the system a name, say \emph{base system}, and refer to it by name for clarity?} 
Because all possible combinations of inputs and outputs were checked, we know that the behavior observed in the small system satisfies all of the desired properties. 

Because of this, we can say that the larger system conforms to a smaller system. Dill has shown that conformance implies that the larger system can not exhibit any additional behavior and thus the larger system also satisfies the desired properties. \cite{dill_trace_theory}
%IS THIS TRUE? NEED TO DOUBLE CHECK ON TRACE THEORY

However, there is a translation between the system implemented in Spin for model checking and the system implemented in Coq for the constructive proof. We must examine these implementations and ensure that they are both representations of the same system. 

\subsection{Examining considered traces}
To examine these implementations we must consider the possible traces of events \emph{considered} by each implementation. 
The Spin model operates on each agent in the system directly and \emph{generates} a trace of events by observing the---sometimes non-deterministic---decisions of each of the agents. The Coq proof does not explicitly model each entity but instead considers all possible traces of events and defines rules that ensure that a trace of events could be generated by a group of agents of size $n$. If the set of traces generated by the Spin model matches exactly the set of traces considered valid in Coq for $n=3$ then we know that the Coq and Spin operate on the same system. The rules were designed to achieve this, but this will need to be verified.

There are 5 possible cases for the set of traces considered in Spin ($S$) and the set of traces considered in the Coq proof ($C$).
\begin{enumerate}
    \item $S \cap C = \varnothing$
    \item $S \cap C \neq \varnothing \wedge S \nsubseteq C \wedge C \nsubseteq S$
    \item $C \subset S$
    \item $S \subset C$
    \item $S = C$
\end{enumerate}

The first case would be unacceptable because it means that the systems evaluated in the Spin and Coq are uncorrelated. The second case is equally bad. There is some correlation but each considers traces the other does not. If the third case is true it would mean that some of the possible behaviors of the system were not considered when checking if the larger system can be projected onto the system with 3 nodes. This would make the Coq proof insufficient. Skipping to the fifth case if both sets are equal that would be ideal. 
That leaves the fourth case. If the Coq proof considers a superset of traces compared to the Spin that may be acceptable if certain conditions are met. 

Proving that the sets are equal directly is difficult. It would require enumerating all traces considered by each system and checking to make sure the sets are equal. If even Spin could be coerced to generate a list of traces the list would include many thousands of possible traces each of which would need to be proven to be valid according to the Coq proof's rules. This is not tractable to complete. However, disproving the other 4 cases would prove that it must be the fifth case. Unfortunately, while the first 3 cases can be easily disproved, disproving case 4 is also difficult. We will begin by verifying that the first 3 cases are not possible then examine the fourth case in more detail.


\subsection{Disproving the first 3 cases}
The first case can be easily dismissed with a counter-example. A trace where no messages are lost and the lift completes successfully is a member of both sets. This is shown to be true by the vacuity check for the fairness property in Spin and there is an example in the Coq where this same trace is proven to be valid.

If we can show that the third case is impossible that eliminates case 2 as well. The third case can be proven by encoding the rules used in the Coq proof as properties in Spin. We can then verify that the rules hold for all of the traces evaluated by Spin. This shows no trace in the set evaluated by Spin violates the Coq rules. This means that the traces evaluated by Coq are at most a superset of the traces. 

To implement the properties to match the Coq rules the Spin model needed to be extended to generate a data structure that recorded the trace of actions. This data structure is referenced in the new properties to verify the rules about traces hold. Because the actions considered in Coq are all inputs and outputs of nodes, to generate this trace of actions it was only necessary to adjust the helper functions that send messages and then add a few lines to add actions to the trace when a message is received. 

After making these adjustments the validity rules can be written in Spin as properties, then Spin will evaluate each trace of events to ensure that the properties hold. 

When Spin verifies these properties it produces some counter-examples which we would like to exclude. These counter examples are cases where because messages are lost the promise does not reach each node. This violates the \emph{has\_required\_actions} rule. However, these traces would be valid for a system of size smaller than 3. Because we are interested only in mapping the Coq proof to the spin model for a system of size 3, we want to introduce a new fairness property that requires the system to be of exactly size 3. This property requires that each node eventually leave the \emph{no\_lift} state. After triggering on this fairness property each of the validity rules was successfully verified to hold for all traces evaluated by Spin. 

Similar to the previous fairness property we added a check to ensure that the new \emph{of\_size\_3} property is achieved. This check passes.

Because of these results, we have verified that the first 3 cases for the intersection of the traces considered in Spin and the traces considered in Coq are not possible. If the 5th case is true that implies that the properties hold for arbitrarily large systems, however, if certain conditions are met we can verify that the properties hold even if the traces considered in Coq are a superset of the traces considered in Spin. 

\subsection{Concerning the 4th case}
Suppose there existed a proof that showed that all systems that communicate in a ring can be extended to any number of nodes. Such a proof would take the form of the fourth case. For this case the superset considered by the proof is sufficient to ensure that the subset of traces we care about in the system maintain the desired properties. However, consider a proof accepted all traces. That would also take the form of the fourth case. If the proof accepted all traces the assertion that all valid traces when projected remain valid can be rewritten as $true \longrightarrow true$ which does not prove anything. For the fourth case to be considered valid we must prove that the conformance proven is strong enough to show that the larger system conforms to a system that was fully evaluated by Spin. 

How can we determine if the conformance property verified is sufficiently strong to prove that the desired properties hold with an arbitrarily large number of nodes? The valid condition must ensure that the set of traces is a trace for a system of size 3, and it must ensure that each of the traces satisfies the fairness property, otherwise it is possible miss some behavior considered vacuously true by Spin. 

We can see in the validity rules that at least one Commit message must be sent, or a ReceiveRef action must be present. Either of these actions being present is sufficient to show that the fairness property is met. The validity rules also define the \emph{all\_ids\_in\_range} rule which ensures that the traces are a set of traces for size 3. These two properties of the rules ensure that the conformance proven in the Coq proof is sufficiently strong to verify the properties continue to hold for an arbitrarily large number of nodes. 

The rules used in the proof are strong and strive to very closely approximate the set of traces considered in Spin.  
A weaker set of rules may have been possible, however certain strengthening of the rules was helpful to make the conformance proof more manageable. 


\section{Related Work}
 
 Nakamoto describes how transferable digital tokens can be double-spent. The paper introduces bitcoins and describes the proof of work method of overcoming this problem which is often referred to as blockchain technology. \cite{bitcoin} 

 Bateman recognizes that the double spending problem is present only in digital currencies that are both duplicatable and transferable. Blockchain technology prevents digital tokens from being duplicated. MyCHIPs instead is designed with non-transferable tokens. MyCHIPs utilizes credit lifts to allow these non-transferable tokens to be virtually fungible and to allow for effective transactions to be made. 
 
 Huang, Ogles, and Mercer prove that \emph{doesn't commute}, a weakened version of the happens-before relation, is sound for certain common classes of task parallel programs. They present a mechanized proof that proves properties for all traces constrained by a partial order. The methods demonstrated by Huang, Ogles, and Mercer can be utilized in this work's mechanized proof that the larger system conforms to the behavior of the smaller system. \cite{ben_DC}

 Bhargavan et. al. Verify Smart Contracts \cite{SmartContracts}. Smart contracts are a type of distributed computation where the program that is executed is secured in a blockchain. While not directly related, smart contracts have the same financial stakes MyCHIPs have and some of their techniques could give inspiration.  Bhargavan et. al, translated the smart contract code into a functional programming language, F*, aimed at verification. This allowed for contract verification based on F* type-checking.
 
 
 Fischer, Lynch, and Paterson,\cite{Fischer} prove the impossibility of consensus on even a Boolean, with even one faulty (or malicious) process. However, this is only true if the processes don't have synchronized clocks. This proof shows the necessity of the referee with strong reachability requirements for the lift algorithm to always eventually reach a consensus on if the lift should commit or be nullified.
 
 
 Schneider summarizes and frames many fault-tolerant distributed algorithms in the framework of  machines\cite{StateMachine}. He shows how many common algorithms are isomorphic to, and can be derived using, the state machine approach. It is a helpful method to characterize and compare different approaches.
 
 Lamport\cite{Lamport}, describes a refinement process that takes a distributed fault-tolerant consensus algorithm and hardens it to be tolerant of byzantine actors through a process he calls \emph{byzantizing.} This method may be useful in future work to ensure the MyCHIPs protocol follows key principles of Byzantine hard protocols.
 
 Delzanno, Tatarek, and Traverso, model check a common consensus algorithm called Paxos in Spin. Their spin constructs provide helpful examples of how distributed algorithms are efficiently modeled.\cite{Delzanno_2014}
 
 Konnov, Veith, and Widder explore the unsolved problems associated with model checking distributed algorithms. This can serve as a hazard map of difficult unsolved problems. It would be unfortunate if solving a known problem that is tangential to this work becomes a prerequisite to finishing. This also can serve to give context to this work and show how it progresses towards solving some of these problems.\cite{Konnov}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{splncs04}
\bibliography{krs_thesis}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\section{The MyCHIPs system}
\label{apdx:mychips}
The MyCHIPs protocol and the methods used to verify it can be understood independently of the system it is used in. However, the curious reader will want to know more about the context in which the MyCHIPs protocol operates. This section provides an overview of the system. More details can be found on Kyle Bateman's website \cite{bateman_myCHIPs}. 
In particular, this section will cover the common challenges with using digital currency, how existing systems overcome those challenges, and how MyCHIPs overcomes those challenges in a unique way that provides additional benefits. 

\subsection{The two types of Money: Commodity and Credit}
The purpose of money is to be a medium of exchange, and it does so by storing value. When someone provides a good or service, the seller is usually given money in exchange. This money stores the value they provided until the seller is ready to redeem that value to get something they need.
For this to work, whatever is used as money needs to be considered valuable. There are two prevailing methods for accomplishing this: commodity money, and credit money. 

In this context, a commodity is anything that can be owned and that can have its right to ownership transferred from one party to another. A commodity derives its value from the economic laws of supply and demand. Because some commodities are consistently desired and are sufficiently scarce, their value is stable enough to be used as money. For example, gold has historically seen widespread use as commodity money. As long as a commodity is in demand and its supply is reasonably limited, it can likely be used as money.

In contrast, credit money exists as a promise from one party to another of future value--likely a commodity or service. If the party giving the promise is trustworthy, the credit money has value equal to what was promised.
%If not, such pledges may be secured by collateral, which is a promise of ownership of an existing commodity should the pledgor fail to deliver on the promise of future value. 

\subsection{Digital Currencies}
Most digital currencies, including Bitcoin and Ethereum, take the commodity money approach. This decision led to two key technical challenges: achieving scarcity, and community consensus on ownership.

\paragraph{Achieving Scarcity}
It can be difficult to make a digital object that can be kept scarce.
Physical commodities, such as gold, are difficult to locate and refine. To mirror this difficulty of discovery, a finite set of digital tokens can be mathematically defined in such a way that they were not known specifically in advance. However any token, once discovered, could be easily checked to determine if it belonged to the set. Furthermore, discovering tokens is often computationally complex enough that it requires significant time and energy to discover a new token. This allows for a commodity that is both digital and scarce.
There are many possible sets that could be used, however, hash functions and blockchains became the prevailing method because using this method simultaneously solves the community consensus problem.

\paragraph{Community Consensus}
For someone to transfer ownership of a commodity, it is important for them to be able to prove that they own the commodity. Because of this, using commodity-based money requires community consensus about who owns what commodities.

Community consensus can be difficult to achieve, especially when many malicious actors may be present. One frequently discussed example where community consensus is not successfully achieved is the \emph{double-spending} problem. \emph{Double spending} is a difficult challenge and efforts to solve the problem lead to the development of blockchain algorithms. 

\subsection{Double-Spending}
Double spending is a challenge that arises when using digital commodities as currency. To spend a commodity-based digital token, an entity must send a transmission that convinces a peer that it owns a digital token and is transferring ownership of that token to the peer. However, if the entity can send one transmission that fulfils this, it can easily send the same transmission to two peers simultaneously. If the peers have no means of communicating with each other (or some third party) then they each have no reason not to accept the digital currency. This allows a malicious actor to “double-spend” a digital token.

\subsection{Overcoming Double-Spending with a Public Ledger}
Most commodity-based digital currencies overcome the double-spending problem is using a public ledger. With a public ledger, each transaction between any entities using the digital currency must be stored in a single public record. By using a public record, double-spending can be identified and prevented. This public ledger may be implemented by assigning a central trusted authority to manage the ledger or it may use a decentralized ledger with a consensus algorithm. 

While using a central trusted authority to manage the ledger is simple, its centralized nature leads to certain risks. First, the central authority is a single point of failure. If the central authority experiences some error and is not able to process transactions for a period of time, all trade using the digital currency would halt. Second, giving the central authority control over all the transactions of a digital currency requires great trust in the authority. The central authority could easily falsify records in order to benefit itself or a third party. In practice, there is not a single authority that every potential user of a digital currency will consider worthy of that amount of trust.

Using a decentralized ledger removes the need for a single trusted authority, but steps must be taken to ensure that the ledger cannot be falsified by an attacker and that a quorum of users eventually agrees on the state of the public ledger. There are two common consensus algorithms used to achieve this: proof-of-work, and proof-of-stake.

\subsubsection{Proof-of-Work}
Proof-of-work consensus algorithms allow for a form of democratic consensus where the group that holds more then 50\% of the computational resources decides the state of the public ledger. The blockchain method accomplishes this by requiring each block to include a partial hash collision. Such a collision will includes a certain number of leading zeros in the result of the hash. Because cryptographic hash functions are designed to be unpredictable and non-reversible, there is no inverse function to compute what data must be added to a record to get the required hash. In order to add a block of data to the ledger an entity must compute many billions of hashes until it finds a partial collision. These blocks are then chained together so the hash of the previous block is included in the next block. 

By chaining these blocks together in order to make a change to a previous block that appears legitimate an attacker must recompute the hash collision for all subsequent blocks. If the attacker does not have more then 50\% of the computation power they won't be able to compute the required hashes faster then the block chain grows and will never be able to make a falsification appear legitimate.

This method has been quite successful at accomplishing its goals, but it has received criticism from the economic and environmental impacts it causes. In order to maintain security of the public ledger the computation work required needs to be great enough to prevent attacks, however computational work is not free. There is very large overhead to purchase and maintain equipment and supply power to be able to complete the computational puzzles required by proof-of-work. This means that transaction costs for block-chain currencies are much higher then traditional transactions. Additionally, the power used for proof-of-work often is generated by burning fossil fuels, which contributes to greenhouse gas emissions and depletes limited resources. Many argue that proof-of-work consensus algorithms are not sustainable. 

\subsubsection{Proof-of-Stake}
In response to these criticisms, algorithms have been implemented that rely on \emph{proof-of-stake} rather then proof of work. Proof-of-stake algorithms rely on similar principles as proof-of-work but rather then allowing anyone to complete the computational puzzle, validators are randomly selected from a pool. To become a validator an entity must place sufficient stake as collateral. If they are found to behave maliciously, their collateral is forfeit. This allows the computation puzzles to be set to be much easier to solve which in turn reduces the overhead and environmental impact of transactions.

\subsubsection{Public Ledgers and Privacy}
Both proof-of-work and proof-of-stake algorithms operate to create consensus on a single, public ledger. The requirement for a public ledger means that no transactions can be made privately. Steps can be taken to attempt to anonymouize transactions but if the identifiers used in the transaction are connected with the individuals they represent, anyone can see the entire history of that person's transactions. Additionally, requiring a consensus on a single public record limits how decentralized the digital currency can be. Because of the privacy concerns, the economic and environmental impact of blockchain transactions, and to make a more decentralized monetary system, an non-blockchain digital currency is desirable. MyCHIPs aims to serve as a credit-based digital currency that avoids these fundamental problems. 

\subsection{Private Credit Digital Currency}

Transferability is intrinsic to commodity money. If you cannot transfer ownership of the commodity you can't transfer the value and it doesn't work as money. Credit money however can be made non-transferable and still maintain value. The promise for goods or services connected with the credit money can be valuable even if that promise is valid only for you. Making tokens non-transferable solves many security problems but leads to other practical problems.

\subsection{Solving the double-spending problem with non-transferability}
To prevent double spending we must ensure that a malicious actor gains no benefit from transferring a digital token to two different peers. Rather then preventing duplication, MyCHIPs instead ensures that tokens are only transferred once. To meet this goal, tokens in the MyCHIPs system are designed to be non-fungible and non-transferable. A token is created for a single recipient and is valid for only that recipient. However, this method has an obvious problem: how does one spend a non-fungible, non-transferable token? MyCHIPs has a method to make CHIPs \emph{virtually fungible} that involves giving the CHIPs back to the issuer in a distributed algorithm called a credit lift.  \cite{bateman_myCHIPs}


\subsubsection{The value of a CHIP}
As mentioned above, blockchain based cryptocurrencies rely primarily on scarcity to drive their value.
Experience has shown how this results in highly volatile valuations over time.
Volatility may be useful in certain investments, but it is generally not desirable in a currency.

In the same way that bonds tend to be less volatile than stocks, a credit-based currency will be more stable than one based on a purely demand-driven commodity.
However, the credit lift algorithm does rely on the assumption that at each stage of the lift, parties are trading tokens that have a uniform nominal value.

This unit of measure is called the CHIP--a clever backronym for Credit Hour in Pool.
The value of a CHIP is defined to be the value of one hour of unskilled labor. Parties agree to this definition in a digital contract when they issue CHIPs.

However, if a laborer is pr oviding tools, or has some expertise in the work they may be able to negotiate receiving more than one CHIP for an hour worth of work.
That is up to the market to decide.
The CHIP definition only quantifies what is being promised with the issuance of each new CHIP.

Unfortunately, it is not very common where the seller of a good wants something directly from the buyer in exchange. To make MyCHIPs useful to facilitate trade the seller needs to be able to use the CHIPs to get goods or services from other entities besides the buyer. This is accomplished through a \emph{credit lift} (hereafter, \emph{lift}).

\subsubsection{The MyCHIPs Credit Lift}
A lift makes CHIPs \emph{virtually fungible} by identifying a circuit where every entity holds CHIPs issued by their predecessor in the circuit. The lift algorithm arranges for each entity in the cycle to forgive the debt of their predecessor to get the same amount forgiven by their successor. 
 
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{ExampleCircuit.png}
    \caption{Example Circuit}
    \label{fig:liftProt}
\end{figure}
How this facilitates trade can be better understood by considering a barter system that involves more than two parties. 
For example, Bob needs his car fixed, John wants solar panels installed on his roof, and Cindy wants a well dug. Cindy knows how to fix cars, Bob knows how to install solar panels, and John is able to dig a well. See Fig. \ref{fig:liftProt} for a graphical representation of this arrangement. If they get together, they can work out a trade where John digs the well for Cindy, Cindy fixes Bob's Car, and Bob installs John's solar panels. Everyone would be happy.

But it is difficult to identify the these cycles before every transaction. This is where money comes in. Using government-backed money like dollars or euros, the process for enabling this transaction might go as follows:
\begin{enumerate}
\item Bob gets a loan from a bank
\item Bob uses the money from the loan to pay Cindy to fix his car.
\item Cindy gives that money to John to dig the well
\item John gives Bob the money to install the solar panels
\item Bob uses the money to repay his loan (but he may need to pay a little 
interest).
\end{enumerate}

MyCHIPs solves the same problem but instead does so by explicitly finding these cycles of value. Each person providing goods or services accepts CHIPs as an IOU for the exchange. Then a successful lift discovers this cycle of value and clears the debts of all involved.

If John, Bob, and Cindy were to use a credit lift to facilitate the arrangement it would go as follows:
\begin{enumerate}
\item Bob asks Cindy to fix his car and agrees to give Cindy 10 CHIPs 
\item Cindy gives John 10 CHIPs to dig the well
\item John gives Bob 10 CHIPs to install the solar panels
\item Cindy talks with Bob and learns that John gave Bob 10 CHIPs
\item Cindy realizes that Bob gave her 10 CHIPs, she gave John 10 CHIPS and John gave Bob 10 CHIPs. There is a cycle!
\item Cindy initiates a lift and \emph{promises} Bob that she will forgive his debt if he can get John to do the same for her. By doing this she takes on the role of the \emph{originator} of the lift. 
\item Bob gives John a similar promise.
\item John gives Cindy a similar promise and Cindy knows the deal is on.
\item Cindy \emph{commits} and gives Bob 10 CHIPs to cancel his debt
\item Bob gives John 10 CHIPs
\item John gives Cindy 10 CHIPs
\end{enumerate}
Everyone's tally for how many CHIPs they have given each other now totals to 0.
We can see this exchange allows for virtual fungibility: each person trades some CHIPs they have received to get back some CHIPs they have given out. 
This resets their balances so they can then give more CHIPs out again in exchange for future goods they will need. 

\section{Details of Coq Definitions}\label{apdx:coq_detail}

\paragraph{has\_required\_actions}
The has\_required\_actions rule is designed to check that the set of traces has all of the actions required by the protocol for a system of a given size. There are two sections to this rule that correspond with the promise and commit phase of the protocol. 

For the promise phase, we ensure that each node in the system receives and sends a promise message. In a real system, some messages may be lost which would cause some nodes to not receive a promise message, however, these cases can be considered to be a system of size $n$, where $n$ is the number of nodes who did receive a promise message. 

For the commit phase, we define a failure point $m$. Each node after $m$ may not receive a commit message and must send a status request to the referee. Each node before $m$ must receive a commit message. This failure point is an important construct for some of the required lemmas to prove the main theorem. To maintain this, a real system must not forward a signature obtained directly from the referee. 

The has\_required\_actions rule enforces a minimum requirement for actions that must be present in the trace, additional actions are permitted.

\paragraph{has\_no\_duplicate\_receives}
The has\_no\_duplicate\_receives rule is designed to check that is only one Receive action for each destination and message type. This rule simplifies the \emph{all\_receives\_causal} rule by allowing it to require only that there exists a corresponding send that happens before. Without this rule it would be necessary to match a corresponding send with each receive to ensure that one sent message is not received twice. This would make the proof much more complex. It is a property about how traces should be recorded. A real system must ensure that all responses to a message are idempotent or that duplicate received messages are ignored. 

\paragraph{all\_receives\_causal}
The all\_receives\_causal rule is designed to check that each receive is preceded by a corresponding send. To define this rule we define is\_send\_for\_receive which given two actions evaluates if the first is a Send and the second is a receive such that the destination of the send is equivalent to the destination of the receive. The equivalent here is defined as equal modulo the size of the system. This allows for messages that \emph{wrap} around the cycle to be considered equivalent without the need to mutate actions during projection. 

We also define a happens\_before function which evaluates to true only if the first action given occurs earlier in the list then the second action. 

Using these two definitions we can check to ensure that every Receive action is preceded by a corresponding send. 

\paragraph{all\_sends\_triggered}
The all\_sends\_triggered rule is designed to check that only the originator sends a message without first receiving a message that triggered that action. This rule again uses the \emph{happens\_before} function to check that that the triggering message is received before the triggered message is sent. 

\paragraph{all\_ids\_in\_range}
The all\_ids\_in\_range rule enforces the size of the system. It defines the allowable values for IDs in source and destination fields. All source fields must be a integer greater or equal to 0 and less then the size of the system. All destination fields can be up to one ID beyond the limit to allow for wrapping. This allows for destinations to be integers greater or equal to -1 and greater or equal to the size. However, messages received from the referee never wrap so they have the same rules as source fields. This property is necessary to identify and discriminate some invalid cases in some Lemmas. 

\paragraph{promise\_forward\_commit\_backward}
The promise\_forward\_commit\_backward rule enforces that promise messages are sent only to successors in the cycle, while commit messages are sent only to predecessors in the cycle. This rule also enforces that if a message wraps around the destination id must be greater then the size or less than 0 rather than using the equivalent id within range. This allows for wrapping messages to easily be identified and preserves monotonicity.

\paragraph{phase\_sequence\_correct}
The MyCHIPs lift protocol operates in two distinct phases, the promise phase, and the commit phase. The phase\_sequence\_correct rule enforces that the originator initiates these phases with the Promise phase first and the commit phase second. This property helps to discriminate invalid situations in some Lemmas.

\paragraph{all\_ref\_receives\_causal}
The all\_ref\_receives\_causal rule is similar to all\_receives\_causal but is is connected with messages to and from the referee. Because there is no need for destination ids to wrap this property is easier to define and prove. 

\end{document}
\endinput
%%
%% End of file `sample-acmtog.tex'.
