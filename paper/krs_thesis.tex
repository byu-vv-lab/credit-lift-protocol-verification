% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{bibnames}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{xcolor}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\newcommand{\originatorstate}{S_O}
\newcommand{\relayastate}{S_1}
\newcommand{\relaybstate}{S_2}
\newcommand{\refstate}{S_R}
\newcommand{\originatorsuccbal}{B^s_O}
\newcommand{\relayasuccbal}{B^s_1}
\newcommand{\relaybsuccbal}{B^s_2}
\newcommand{\originatorpredbal}{B^p_O}
\newcommand{\relayapredbal}{B^p_1}
\newcommand{\relaybpredbal}{B^p_2}
\newcommand{\nolift}{\emph{NO\_LIFT}}
\newcommand{\pend}{\emph{PEND}}
\newcommand{\call}{\emph{CALL}}
\newcommand{\void}{\emph{VOID}}
\newcommand{\good}{\emph{GOOD}}
\newcommand{\always}{\emph{always}}
\newcommand{\eventually}{\emph{eventually}}
\newcommand{\fair}{$F$}
\newcommand{\action}{\mathds{A}}
\newcommand{\listaction}{[\action]}
\newcommand{\promise}{\emph{promise}}
\newcommand{\commit}{\emph{commit}}
\newcommand{\happensbefore}{\prec_A}
\newcommand{\actsvalid}[2]{\mathds{V}(#1, #2)}
\newcommand{\projectsize}[2]{\mathds{P}(#1, #2)}

\newcommand{\hra}[2]{\emph{has\_required\_actions}(#1, #2)}
\newcommand{\hndr}[1]{\emph{has\_no\_duplicate\_receives}(#1)}
\newcommand{\allrc}[2]{\emph{all\_receives\_causal}(#1, #2)}
\newcommand{\allst}[1]{\emph{all\_sends\_triggered}(#1)}
\newcommand{\allir}[2]{\emph{all\_ids\_in\_range}(#1, #2)}
\newcommand{\pfcb}[1]{\emph{promise\_forward\_commit\_backward}(#1)}
\newcommand{\psc}[1]{\emph{phase\_sequence\_correct}(#1)}
\newcommand{\allrrc}[1]{\emph{all\_ref\_receives\_causal}(#1)}

\newcommand{\coderepository}{\emph{GotChoices} github repository \cite{bateman_myCHIPs}}

\newif\ifcomments
\commentstrue
\newcommand{\egm}[1]{\ifcomments\textcolor{orange}{egm: #1}\fi}
\newcommand{\krs}[1]{\ifcomments\textcolor{blue}{krs: #1}\fi}


\begin{document}

\title{Extending Model Checking using Inductive Proofs in Distributed Digital Currency Protocols}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Kyle Storey \and Eric Mercer\orcidID{0000-0002-2264-2958}}
\institute{{Brigham Young University, Provo UT 84602, USA}
\email{kyle.r.storey@gmail.com,egm@cs.byu.edu}}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

Model checking is an effective method to verify both safety and liveness properties in distributed systems. However, the complexity of model checking grows exponentially with the number of entities which makes it suitable only for small systems.
Interactive theorem provers allow for machine-verified proofs. These proofs can include inductive reasoning which allows them to reason about an arbitrarily large number of entities. However, proving safety and liveness properties in these proofs can be difficult.
This work explores how combining model checking and inductive proofs can be an effective method for formally verifying complex distributed protocols. This is demonstrated on a part of MyCHIPs, a novel digital currency based on the value of personal credit \cite{bateman_myCHIPs}. It has been selected as a case study because it requires certain properties to hold on a non-trivial distributed algorithm. 

%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Model checking, interactive theorem provers, formal verification, distributed systems, digital currency}

\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}
%\end{CCSXML}

%\ccsdesc[500]{Computer systems organization~Embedded systems}
%\ccsdesc[300]{Computer systems organization~Redundancy}
%\ccsdesc{Computer systems organization~Robotics}
%\ccsdesc[100]{Networks~Network reliability}



%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\section{Introduction}
\label{chap:introduction}
This work combines model checking with interactive theorem provers to verify safety and liveness properties in arbitrarily large distributed systems.
It uses a \emph{white box} approach for the model checking, which utilizes information about the internal state of each entity to verify certain properties hold.
It uses a \emph{black box} approach in the theorem prover, where only the inputs and outputs of each entity are considered.
If the set of observed inputs and outputs of each entity is unchanged as the system grows larger, then the set of internal states of each entity is unchanged.
When the set of inputs and outputs remains unchanged we say that the larger system \emph{conforms} to the smaller system \cite{dill_trace_theory}. This implies that the safety and liveness properties verified in the model checker continue to hold as the system grows large.

This process is demonstrated in a case study of MyCHIPs. MyCHIPs employs a distributed protocol as a means of facilitating the trade of goods and services between trusting partners. There are many temporal properties that must hold for MyCHIPs to meet its security and functionality requirements. This work verifies several of those properties.

In particular, this work verifies a distributed algorithm in the MyCHIPs system called a \emph{credit lift}. A \emph{credit lift} (\emph{lift} for brevity) in the MyCHIPs protocol operates on a group of agents arranged in a cycle such that each agent is in debt to its sucessor in the cycle. The protocol aranges for each to forgive their predecessor's debt, and in exchange, their own debt is forgiven. This protocol is critical for the MyCHIPs system to work correctly as a digital currency. Details of how this protocol fits in the larger system can be found in the appendix \ref{apdx:mychips}.

The debt clearing is done in two stages. First, each entity \emph{promises} to send CHIPs to their predecessor. Then, once all have promised, each entity \emph{commits} and sends CHIPs as promised. Once all have sent CHIPs, each entity's \emph{balance}--the difference between the number of sent CHIPs and the number of received CHIPs--remains the same, but they have cleared their liabilities. 

Unfortunately, sometimes entities on the MyCHIPs network may lose connectivity or otherwise become \emph{inactive}. An inactive node may not send or receive messages for an unbounded amount of time. It is not acceptable for lifts to hang in an unfinished state indefinitely. To prevent this, each lift is given a time limit, represented by a timestamp at which time the lift can no longer be committed. Because we don't expect entities on the network to have synchronized clocks, a referee is appointed whose clock is considered authoritative and acts as a consensus object. If the originator requests to commit before the timeout, the referee provides a digital signature that is proof that the lift has been committed. If the lift is not committed before the timeout, the lift becomes \emph{nullified} and the referee will digitally sign a statement that the lift has been nullified.

\subsection{Required Properties for MyCHIPs Correctness}\label{sec:requiredProperties}

MyCHIPS claims certain properties hold for its lift protocol but makes no formal arguments to prove those claims. This work formally proves some of those properties. These properties must hold for all compliant nodes on the network and must hold regardless of the number of nodes that participate in a lift. 

The properties this work will verify are as follows:

\begin{enumerate}
\item Lifts always eventually are committed or nullified for every active node. 
\item At the final state of the lift, every active node agrees that the lift was committed or every active node agrees the lift was nullified. 
\item The balance of every active node on the final state of the lift is equal to or greater than its initial balance.
\item Every active pair of nodes on the final state of the lift agree on their shared tally.
\end{enumerate}

Using a model checker, this work proves these properties hold in a system with just one originator---the node that initates the lift algorithm---one referee, and two relay nodes---nodes that participate in the lift that are not the originator or a referee. This work also defines a set of rules about a trace of events based on the constraints of the protocol. These rules can be used to determine if a trace of events is allowed by the protocol for a system of a given size. 
Then in the proof assistant Coq, we define the set of traces of events that are allowed by these rules. This is designed to enumerate the same set of traces checked by our model checker. This set of traces acts as an expression context as described by Dill \cite{dill_trace_theory} to define a conformation relation. If one subsystem conforms to another, it can be substituted without affecting the rest of the system's behavior. 
Using the model checking results as a base case, we prove that the set of traces produced by a chain of $n+1$ relay nodes conforms to the set of traces produced by $n$ relay nodes and inductively argue that the properties verified by model checking hold for any number of nodes.

\section{MyCHIPs protocol}
This section formally defines the MyCHIPs protocol, identifies the critical processes that require verification, and introduces the methods used to verify those processes.

\subsection{Credit Lift Algorithm}\label{sec:liftAlgorithm}
The MyCHIPs credit lift protocol described in Appendix \ref{apdx:coq_detail}, consists of three phases: discovery, promise, and commit. In the discovery phase, a circuit is identified where each entity is willing to participate in a lift. The correctness of the discovery phase is not critical because no transfer of value occurs during this phase. As such, this phase will not be verified.
Fig. \ref{fig:liftSequence} describes an example of a sequence of messages that would be passed in a typical lift during the promise and commit phases.

The originator initiates the lift by sending Relay 1 a lift record
$r = \langle id, value, ref, timeout\rangle.$ This record has a unique identifier, the lift value, the network ID of a referee that the originator selects, and a timeout timestamp. Sending this lift record represents a \promise and once Relay 1 obtains the referee's signature they can immediately add the number of chips specified in the lift record to its tally with the originator.

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{SequenceDiagramLifeline.png}
    \caption{Lift Protocol Sequence Example}
    \label{fig:liftSequence}
\end{figure}

When Relay 1 receives the lift record, it first confirms that it trusts the referee to be fair and available, and it confirms that the timeout timestamp is acceptable. If the referee is not trusted, or the known route to the target is no longer valid (for instance if it was used in a different lift and the node no longer has debt on that route to clear) it may choose to not continue. The node can optionally return a message indicating that it does not intend to complete the lift, or the node can simply ignore the message and wait for the lift to timeout. In the model used for verification, nodes ignore messages if they do not intend to participate in a lift. In our example, Relay 1 wishes to participate, so it forwards the lift record along with its own promise to Relay 2. Relay 2 then similarly evaluates the lift and decides to forward a promise to its predecessor which happens to be the originator. 

When the originator receives the promise from Relay 2, the lift moves into the commit phase and the originator sends the lift record to the referee to request a signature to commit. 

When the referee receives a lift record with a request to commit, it checks its clock to see if it received the commit message before the timeout. If it received the commit message after timeout, the Referee signs a statement nullifying the lift. If it received the commit message before the timeout, the referee signs the lift record and returns its signature to the originator. In either case, it records its result to provide to any node that requests the status of the lift. In the sequence diagram in Fig. \ref{fig:liftSequence}, the referee decides the commit message was received in time and sends the originator its signature.

When the originator receives the signature, it sends it to its successor in the circuit (Relay 2). Whenever a node in the circuit receives the signature, immediately the CHIPs it promised to its successor are valid. (i.e. it has forgiven the debt of its successor). 
To recover this value, it sends the signature to its predecessor.

In the sequence shown in Fig. \ref{fig:liftSequence}, once Relay 2 receives the signature, it experiences a long delay. Because of this delay, Relay 1 determines the lift is taking longer than expected and sends a message to the Referee to check the status of the lift. When the referee receives the status request, it checks its records and recalls the signature it previously provided to the originator. Because the lift is committed, the referee provides this signature to Relay 1. When a node receives a signature from the Referee instead of its predecessor it should not forward this signature. This ensures there is exactly one failure point in the cycle after which every node must obtain the lift status from the referee. This property is useful in proving the correctness of the protocol. However, eventually, Relay 1 receives the signature from Relay 2 which allows it to forward the signature. If the message sent by Relay 2 had arrived sooner, Relay 1 would not have needed to request the status from the Referee. Once the originator receives the signature from Relay 1, all nodes have received exactly the amount of CHIPs they have given and the lift is complete.

Note that the protocol makes a distinction between three roles nodes can take: originator, referee, or relay. In every lift, there is always exactly one originator, and exactly one referee, and there can be any number of relay nodes. These roles determine the types of actions a node can take and therefore define distinct equivalence classes to consider. 

\begin{figure}
    \centering
    \includegraphics[scale=0.42]{LiftStatesSeperate.png}
    \caption{Lift States Diagram}
    \label{fig:liftStates}
\end{figure}

Fig. \ref{fig:liftStates} describes the behavior expected from each of these equivalence classes as mealy machines.
These mealy machines are based on the state machines Bateman provides to define the protocol. \cite{bateman_state_machines} 
In the figure, each box represents the state of the lift from the perspective of the node, and each arrow represents a change in state and an associated action that is taken during the transition from one state to the next. Each transition is labeled with a condition that must be true for the transition to be taken, separated by a $/$ from an action that is taken during the transition. Each node has stored: the network ID of its predecessor (Pred), its successor (Succ), and the Referee. A transition can be made conditional on receiving a particular message from a particular network ID. This case is written in the form \emph{sender} $?$ \emph{message\_type}. As an action during a transition, nodes may transmit a particular message to a particular network ID. This case is written in the form \emph{recipient} $!$ \emph{message\_type}. 

The Spin model used as the model checking system is based on the mealy machine in Fig. \ref{fig:liftStates}. The details of that implementation are described in Section \ref{chap:model_checking_results}. The set of rules for the proof in Coq are defined based on the mealy machine in Fig. \ref{fig:liftStates} and the sequence diagram in \ref{fig:liftSequence}. Details of that implementation are described in Section \ref{chap:coq_results}.


\section{Model Checking} \label{chap:model_checking_results}
The safety and liveness properties required for the MyCHIPs lift protocol can be proven by an exhaustive search all possible states in a small system. Spin is a powerful model-checking tool that allows for these types of properties to be expressed and verified. The state required by the system can be split into two classes: the part of the state that is evaluated when checking the properties, and the state that is used only to determine which state transition to take. We provide a formal definition of the former, and describe the latter intuitively. The source code for the complete spin model can be found on the \coderepository.
\subsection{Definition of the system state}\label{sec:statedef}
The system state is a combination of the individual states for each node. The state for the originator and each relay node can be represented as:
$$Node~state \equiv \langle S, B^s, B^p \rangle$$
$$
S \in \{\nolift, \pend, \call, \void, \good\}
$$
$$
B^s, B^p \in \mathds{Z}
$$
Here $S$ represents the mealy machine state and $B^s$ and $B^p$ represent the change in balance with the node's successor or predecessor respectively.

The state of the referee is similar except that it omits the balances
$$Referee~state \equiv \langle S \rangle$$

These are then composed together as a system state:
$$System~state \equiv \langle S_O, S_1, S_2, S_R, B^s_O, B^p_O, B^s_1, B^p_1, B^s_2, B^p_2  \rangle$$

With the $O$ subscript representing the \emph{originator}, $1$ and $2$ representing the first and second \emph{relay} nodes, and $R$ representing the \emph{referee}.

\subsection{Definition of the properties}
The desired properties are defined in terms of the simplified state presented in section \ref{sec:statedef}: 
The properties verified in the Spin include a fairness property, and each of the properties described in section \ref{sec:requiredProperties}. 

\subsection{Linear-time temporal logic}
Linear-time temporal logic (LTL) allows for liveness properties to be defined. There are two temporal operators defined in LTL that are used to define the properties: \emph{always} and \emph{eventually}

The \emph{always} operator defines a property that holds only if the associated predicate is true for every possible system state.

The \emph{eventually} operator defines a property that holds if for all paths through the system state space there exists a state where the associated predicate is true. If there exists a single path where the predicate is never true the property does not hold. That single path may be a path to a termination state, or it could just be a cycle of states. 

The composition \emph{always eventually} is used to make claims about the final state of the system. Using the \emph{eventually} construct alone will accept a trace where a predicate holds for a moment but doesn't hold later in the trace. Using \emph{always eventually} ensures that the conditional holds at all final states of the system (or any loop of non-final states). 


\begin{definition}[A fairness property]
\begin{multline*}
    F \equiv \eventually \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}
\end{definition}
A fairness property is required as a consequence for not explicitly modeling time as described in section \ref{sec:model_time}. The referee must decide if a lift should be committed or nullified based on a timeout. When a node requests the status of a lift the referee may return a \good\ or \void\ message or they may send a \pend\ message if the timeout has not been reached yet and the lift is not yet committed. However, because this decision is modeled as a non-deterministic choice, the model considers the possibility that the referee will always send a pend message in an endless loop with one of the nodes. Spin identifies this case and provides it as a counter-example for many of the properties. However, no matter how far into the future the timeout was set, eventually, the timeout will expire. So that counter-example is infeasible and not interesting for us. 

To tell Spin this is a case we are not interested in we define a fairness property that says that eventually the Referee is either in the \good or the \void state. However, when introducing a fairness constraint it is important to verify that that constraint can be met. If that constraint can not be met the properties will be \emph{vaccuously true}. Because of this, we need to add a new property to verify that the constraint is met in at least 1 case---and likely almost all cases. This would normally take the form of an existential property. Unfortunately, Spin does not perform well to prove existentials so instead we create a property that says that it is never true that the fairness property is met. We expect this property to fail. If it does it means that there are cases where the fairness property holds.

Then we write all our properties such that we claim only that if our fairness property holds does our desired property hold. This effectively trims out that infeasible case and allows Spin to continue and verify the remaining properties. 

\begin{definition}[Property 1]
\begin{multline*}
    P_1 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorstate = \good \vee \originatorstate = \void) \wedge \\
     (\relayastate = \good \vee \relayastate = \void) \wedge \\
     (\relaybstate = \good \vee \relaybstate = \void) \wedge \\
     (\refstate = \good \vee \refstate = \void) \\
\end{multline*}
\end{definition}
The purpose of $P_1$ is to verify that lifts always eventually are committed or nullified for every active node. Put differently nodes are not left hanging with an incomplete lift forever. 
When a lift at a node is committed it moves the lift into the \good state. When a lift at a node is nullified it moves the lift into the \void state. If the state is either \good or \void then the lift is in a final state. In the model, there are 4 nodes: the originator, two relay nodes, and the referee. For each of these nodes, we need to check that in all possible scenarios they eventually are all in a final state. Using the always eventually construct we check that the originator, the two relays, and the referee are all in the final state. 

\begin{definition}[Property 2]
    
\begin{multline*}
P_2 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorstate = \relayastate = \relaybstate = \refstate) \\
\end{multline*}
\end{definition}
The purpose of $P_2$ is to verify that at the final state of the lift, every active node agrees that the lift was committed or every active node agrees the lift was nullified. We again use the always eventually construct to ensure this property holds at the final state of the system. To check that all nodes are in agreement on the state of the lift we check to ensure that The originator's state is equal to the first relay's state, the first relay's state is equal to the second relay's state, and that the second relay's state is equal to the referee's state. This implies by transitivity that all nodes have the same final state. If this Boolean expression is true at the final state then all nodes are in agreement on the final state of the lift.

\begin{definition}[Property 3]
\begin{multline*}
P_3 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorsuccbal + \originatorpredbal \ge 0) \wedge
    (\relayasuccbal + \relayapredbal \ge 0) \wedge
    (\relaybsuccbal + \relaybpredbal \ge 0) \\
\end{multline*}
\end{definition}

The purpose of $P_3$ is to verify that the balance of every active node on the final state of the lift is equal to or greater than its initial balance. Because the starting balance is not needed to implement the model we record the change in a node's balance with its partners rather than its total balance. The model tracks the change in the balance of a node with its successor in \emph{balanceSuccDelta}, and its predecessor in \emph{balancePredDelta}. In a successful lift, we expect the sum of these balances to be zero. However, if a node fails and stops transmitting, its successor might obtain the signature from the referee. When it does so it can use it to collect chips from its successor without needing to send chips to its predecessor. This is an allowable result so we allow the sum of the change in balances to be greater than zero to allow for this case.

In $P_3$ we verify that each node's balance is equal to or greater than its starting balance. Again we make use of the always eventually construct to ensure that this condition holds at the final state of the system.

\begin{definition}[Property 4]
\begin{multline*}
P_4 \equiv \always\ \eventually,\ \fair \longrightarrow \\
    (\originatorsuccbal = \relayapredbal) \wedge
    (\relayasuccbal = \relaybpredbal) \wedge
    (\relaybsuccbal = \originatorpredbal) \\
\end{multline*}
\end{definition}


$P_4$ ensures that always eventually every pair of nodes agrees on the change in the balance between them. 



\subsection{Implementation of Node State Machines} 
To implement the protocol as described by the mealy machine above we need to implement three process types: Originator, Relay, and Referee. Each process has a unique set of edges marked as non-deterministic choices that are enabled only when the current state $S$ matches the state of the edge in the diagram, and---if applicable---when the triggering message is present at the front of a message queue.



\subsection{Implementation of Message Passing}
\subsubsection{Channels}
The message passing between nodes is modeled by creating 3 message channels for each node. One for messages received from the node's successor in the cycle, one for messages from the predecessor and one for messages from the referee. The referee also has a channel where it receives messages.

\subsubsection{Message Types}
The details of the message are not important for the model, instead, each message will have a specific type. It is expected that nodes in a real system will verify that messages are valid as part of processing a received message. For the model, we will consider invalid messages as if they were never received. Once a valid message is received, the type of that message will inform the actions a node will take in response to the message. Examining the state machines we can see that knowing the messages type is sufficient for our model. 

\subsubsection{Message Loss}
Rather than using the channels directly, the state machines for each node use helper functions to send messages. These helper functions to determine which node the message should be sent to and puts the message in the appropriate channel. These helper functions also model the possibility that a message might be lost in transit. Whenever a message is sent, Spin models it as a non-deterministic choice on whether the message should be placed in the appropriate message queue or dropped. In its model checking, Spin will evaluate all combinations of lost messages. One unique case is the possibility that all messages from a given node are dropped. This models the case where a node crashed or otherwise lost connection to the network. 

The protocol requires that the referee should be a node that is consistently available so messages to and from the referee are never dropped. This is required to prove some of the required liveness properties. Without this requirement, the problem is isomorphic with the \emph{two generals problem}, and it is impossible to guarantee eventual consensus on the lift status. This requirement enforces that eventually every message sent to and from the referee will be received, however, the model will evaluate the possibilities that arise should those messages take a very long time. 

\subsection{Modeling Time}
\label{sec:model_time}
Because we don't expect nodes to have synchronized clocks, modeling time for each node becomes extremely computationally complex. Rather than modeling time explicitly, we allow all decisions that would be made by a node based on time to be a non-deterministic choice. This allows the model to explore all combinations of time-drift and all behavior that could arise without the need to model time. Leaving out time reduces the state space considerably and makes the analysis computationally feasible. 

\subsection{Results}

To verify each of these properties, Spin evaluated 
577244 unique states with 240285 edges between those states. Evaluating each property spin found that there were no counter-examples that both satisfied the fairness property and violated one of the properties. We also verified that the fairness property is satisfied in some (presumably all but very few) cases. 

From these results, we can conclude that the properties hold for a system with one originator, two relay nodes, and one referee, for all possible orderings and types of messages sent and for all combinations of messages failing to be delivered.

\section{Inductive Proof} \label{chap:coq_results}

Coq is a popular interactive theorem prover that can be used to define and prove properties. Inductive reasoning techniques can be used in Coq to state and prove properties of arbitrarily large systems. This work implements a proof that shows that all possible traces that satisfy the validity rules for a system of arbitrary size $n$ can be \emph{projected} to a base system of size $3$ without changing the inputs or outputs of the remaining nodes. Because the inputs and outputs are unchanged we can say that the larger system conforms to the smaller system. This implies that the behavior is unchanged and thus the desired properties proven by the model checking as described in Section \ref{chap:model_checking_results} continue to hold for an arbitrarily large system.
The details of the implementation can be 
found on the \emph{GotChoices} github repository \cite{bateman_myCHIPs}. 

\subsection{Definitions} \label{sec:definitions}
The MyCHIPs system in the Coq proof is written with a \emph{black box} approach. The Coq proof does not need to know anything about the internal state of each of the nodes. To prove that a larger system conforms to a smaller system we need only show that the set of possible inputs and outputs of each node are equivalent regardless of the size of the system. Because of this many of the variables in the Spin model, including the current balance, and each nodes lift state are omited from the Coq definitions. 
\krs{We also omit some interactions between the originator and the referee. But the goal of including the originator at all is to provide context for the relay nodes. I need to adjust some language here to better reflect that.}

Rather than considering each individual node in the system, the Coq proof operates on traces of actions that might occur in the system. Each trace is represented with an ordered list of \emph{Actions}. The list represents the actions that each node took in the system in the order that they took them.

We define rules that must hold for a trace of actions to be considered valid. We define these rules such that all possible traces of actions in the system are considered valid, and all impossible traces are considered invalid. These rules include properties that are enforced by the MyCHIPs protocol as well as properties that are intrinsic to any distributed system. For example, we enforce  messages can only be received after the message has been sent.

We define four distinct kinds of actions: \emph{Send}, \emph{Receive}, \emph{SendRef}, and \emph{ReceiveRef}.
There are also two explicit types of messages, \promise and \commit, as well as one implicit message type which is the status request messages exchanged with the referee.
If a node requests the status from the referee but that referee responds with a \emph{PEND} response, those actions do not affect node state so are omitted from the proofs action trace.

Each node in the cycle has a unique ID represented by an integer. The Originator's ID is 0, with all other nodes in the system having some ID greater then 0. The referee does not have an ID but instead, the special SendRef and ReceiveRef actions are used for actions that communicate with the referee. 

\subsubsection{Validity Rules} \label{sec:validity_rules}
The rules that determine if a trace of actions is valid are defined in \emph{acts\_valid}. There are 8 rules:

\begin{enumerate}
  \itemsep 0pt
  \item \emph{has\_required\_actions}
  \item \emph{has\_no\_duplicate\_receives}
  \item \emph{all\_receives\_causal}
  \item \emph{all\_sends\_triggered}
  \item \emph{all\_ids\_in\_range acts}
  \item \emph{promise\_forward\_commit\_backward}
  \item \emph{phase\_sequence\_correct}
  \item \emph{all\_ref\_receives\_causal}
\end{enumerate}

All must hold for a trace of actions to be considered valid. The rules were designed to exactly match the possible traces that could be generated by a system of nodes for the given size. Each of these rules are defined formally below and described in detail in Appendix \ref{apdx:coq_detail}.

For the following definitions, we define an action type 
$$\action \in \{(Send, s, d, m), (Receive, d, m), (SendRef, s) (ReceiveRef, d)\}$$
with source identifier $s \in \mathds{Z}$, destination identifier $d \in \mathds{Z}$, and a message $m \in \{Promise, Commit\}$. We also define a trace of actions 
$A \in (a_1, a_2, ... a_n), a_i \in \action,$ as well as a size $S \in \mathds{N}, S = n.$

\begin{definition}[has\_required\_actions] The trace contains the required Sends and Receives with Promise Messages, and nodes before a given failure point $m$ have the required Sends and Receives with Commit messages, or if they are after a given failure point they request the lift status from the referee.

$$
   \forall n \in \mathds{N}, n + 1 < S \longrightarrow \\
   (Send, n, n+1, Promise) \in A \wedge (Receive, n, Promise) \in A\ \\
$$
$$ \wedge \\ $$
$$
   \exists m \in \mathds{N}, \forall n \in \mathds{N}, \\
$$
$$
   (n \ge m) \longrightarrow (n + 1 < S) \longrightarrow \\
   (Send, n+1, n, Commit) \in A \wedge (Receive, n, Commit) \in A\ \\
$$
$$ \wedge \\ $$
$$
   (n < m) \longrightarrow (n < S) \longrightarrow \\
   (SendRef, n) \in A \wedge (ReceiveRef, n) \in A\ \\
$$
$$ \wedge \\ $$
$$
    (Send, 0, -1, Commit) \in A \\
$$
\end{definition}

\begin{definition}[has\_no\_duplicate\_receives]
The trace contains at most one of each receive action. 
$Given\ r = (Receive, d, m), n \in \mathds{N}, m \in \emph{Message},\ \sum_{A}[x=r] \le 1$. Which counts the number of occurrences where $x=r$ in $A$. 
\end{definition}

\begin{definition}[all\_receives\_causal]
Every Receive action is preceded by a Send action where a message of that type is sent to the destination. Given $r = (Receive, d, m), r \in A \longrightarrow \exists a = (Send, s, d^*, m), a \in A \wedge d^* = d \mod S \wedge a \happensbefore r.$ Where $\happensbefore$ is the happens-before relation over $A$, indicating that $a$ occurs before $r$ in the trace of events. 
\end{definition}

Because we allow the destination of a \emph{Send} to be an integer between $-1$ and the size \emph{inclusive} this means that a node can send to ID $-1$ and this always corresponds with the node with the maximum ID in the system. Also in the original system a node might send a message to the node with ID $n$, but when we project to size $n$ the node with ID $n$ is removed from the system. This send---instead of being sent to a node that doesn't exist---now gets mapped to node $0$ because the destination need only be equal modulo the size. This allows for the projection to work without the need to mutate actions, which makes proving properties about the projected system much simpler.  

\begin{definition}[all\_sends\_triggered] Only the originator sends a message without first receiving a message of the same type.
Given $a = (Send s, d, m), s \neq 0 \longrightarrow a \in A \longrightarrow \exists r, r = (Receive, s, m) \wedge r \in A \wedge r \happensbefore a$
\end{definition}

\begin{definition}[all\_ids\_in\_range] Ensures the trace only includes identifiers for nodes that are in a system of the given size. Destinations of a send are allowed to \emph{wrap} by one identifier. Given $a \in \action, a = (Send, s, d, m) \longrightarrow 0 \le s < \S \wedge -1 \le d \le S$
\end{definition}

\begin{definition}[promise\_forward\_commit\_backward] All Promise messages are sent to the successor in the cycle and all Receive messages are sent to the predecessor. Given $a = (Send, s, d, m), a \in A \longrightarrow [(m = Promise \longrightarrow d = s + 1) \wedge (m = Commit \longrightarrow s = d + 1)]$
\end{definition}
\begin{definition}[phase\_sequence\_correct] The originator sends the first Commit message, and the originator is the last to receive each type of message. Given $a, b \in A$,
$$ 
a = (Send, 0, -1, Commit) \longrightarrow 
$$
$$
[
(b = (*, s, d, Commit) \wedge (s \neq 0 \vee d \neq -1) \longrightarrow a \happensbefore b)
\wedge 
(b = (Send, s, d, Promise) \longrightarrow b \happensbefore a)
]
$$
$$
a = (Receive, 0, m) \longrightarrow 
$$
$$
[
b = (Send, s, d, m) \longrightarrow b \happensbefore a
]
$$
\end{definition}
\begin{definition}[all\_ref\_receives\_causal] No nodes receive a message from the referee before they have sent a message to the referee. Given $r = (ReceiveRef, d), r \in A \longrightarrow \exists a = (SendRef, d), a \in A \wedge a \happensbefore r$
\end{definition}


\subsection{Projection}
Projection is defined with the \emph{projected} function. Given the size of the system we would like to project onto and an action, the \emph{projected} function determines if s given n action is kept or omitted in the projected trace. It uses a special type  
$option \action \in \{\emph{None}, \emph{Some a}\}$ with $a \in \action$.

\emph{projected} returns $\emph{None}$ if the given action should be omitted and $\emph{Some} a$ with a being the given action if the action should be kept in the projected trace.

The projection function has the following properties:
\begin{multline*}
a = (Send, s, d, m), \longrightarrow \\
s \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
d > S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (Receive, d, m), \longrightarrow \\
d \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (SendRef, s), \longrightarrow \\
s \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}
\begin{multline*}
a = (ReceiveRef, d), \longrightarrow \\
d \ge S \longrightarrow \emph{projected}(a, S) = \emph{None} \\
\end{multline*}

For all other cases 
$$\emph{projected}(a, S) = \emph{Some}\ a$$


The type of the projected function would allow mutations of actions if necessary. Early attempts at the proof mutated actions to \emph{wrap} a sent message around to $0$ or $size-1$ when the destination was projected out. However, allowing actions to mutate as part of the projection increased the complexity of the proof. Using the modulo arithmetic construct to handle wrapping provides a more robust mathematical foundation. In the final proof, the projeciton never mutates actions only omits them if necessary. 

\subsubsection{project\_to\_size} 
Given a size and a list of actions, \emph{project\_to\_size} returns a new list of actions that omits all actions for which \emph{projected} returns None. 

\subsection{Proofs}

The proof consists of a set lemmas that progressively build from basic principles to the main conformance property we would like to prove. The \emph{stack} of supporting lemmas is visualized in Figure \ref{fig:coqLemmaStack}.


The main theorem proven in the coq script is called \emph{all\_valid\_systems\_conform\_to\_size\_3}. It is defined using \emph{acts\_valid} which is the validity rules described in Section \ref{sec:validity_rules}. It also uses \emph{project\_to\_size} which is a function that defines how projections are performed. Definitions of the \emph{acts\_valid} predicate and \emph{project\_to\_size} function are provided in seciton \ref{sec:definitions} above.
For brevity the symbols $\mathds{V}$ and $\mathds{P}$ are used for \emph{acts\_valid} and \emph{project\_to\_size} respectively.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.35]{CoqLemmaStack.png}
    \caption{Stack of Supporting Lemmas}
    \label{fig:coqLemmaStack}
\end{figure}


\begin{theorem}{all\_valid\_systems\_conform\_to\_size\_3}
$$\forall A \in \listaction\ \actsvalid{A}{n} \wedge n > 3 \longrightarrow \actsvalid{\projectsize{A}{3}}{3}.$$
\end{theorem}
This main theorem is proven by induction on $n$: the size of the original system. It begins by eliminating cases where the system size is smaller or equal to 3, then uses a lemma \emph{larger\_conforms\_to\_smaller} to prove it holds for the system of size 4. We then use the lemma \emph{projected\_larger\_conforms\_to\_smaller} which is similar to \emph{larger\_conforms\_to\_smaller} except that it operates on a system that has already been projected. This allows us to reduce the size of the original system by one at a time until we reach the 3-node base case which was proven previously.  In this way, these lemmas can be used to execute an inductive step that proves the property. 

\begin{lemma}{larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ \actsvalid{A}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$
\end{lemma}

The \emph{larger\_conforms\_to\_smaller} lemma proves that all systems of size $n+1$ conform to a system of size $n$. This lemma relies on sublemmas that prove that most of the validity rules are independent of projection. Meaning if the rule holds in a system they continue to hold when projected to a smaller system. The only exception is the \emph{all\_receives\_causal} rule which is not independent of projection. Instead, we use a lemma \emph{valid\_implies\_all\_receives\_causal\_in\_proj} which shows that any valid system still maintains the \emph{all\_receives\_causal} rule in the projected system. Details of those proofs are described later in this section. 


\begin{lemma}{projected\_larger\_conforms\_to\_smaller}
$$\forall A \in \listaction\ n \in \mathds{N}, \actsvalid{\projectsize{A}{n+1}}{n+1} \wedge n > 2 \longrightarrow \actsvalid{\projectsize{A}{n}}{n}.$$
\end{lemma}
This lemma is used as an intermediary step between the original large system and the projection down to size 3. It states that given a set of acts of some larger size $m$, if that larger system when projected to size $n+1$ is valid that implies that the system when projected to size $n$ is valid.

It makes use of a sublemma \emph{project\_idempotent} which proves that projecting to some size $n$ and then projecting to some smaller size $m$ is equivilant to projecting directly to the smaller size $m$. This combined with the lemmas proving the rules are independent of the projection used in \emph{larger\_conforms\_to\_smaller} prove this property.

\begin{lemma}{project\_idempotent}
$$\forall A \in \listaction\ n0\ n1 \in \mathds{N}, n0 < n1 \longrightarrow \projectsize{\projectsize{A}{n1}}{n0} = \projectsize{A}{n0}.$$
\end{lemma}
This lemma proves that projecting first to a larger size, $n$, then to a smaller size, $m$, is equivilant to projecting to size $m$ directly. This is proven directly through induction on the list of actions, and case analysis of each type of action. 

The intuition is that actions are removed when one of there parameters is smaller then the size. Because $n>m$ we know that if an action was omitted in the projection to size $n$ then it also is omitted in the projection to size $m$.  

\begin{lemma}{has\_required\_actions\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \hra{A}{n+1} \longrightarrow \\
\hra{\projectsize{A}{n}}{n}
\end{multline*}
\end{lemma}


This lemma proves that if a trace of actions has all the required actions for size $n+1$ that implies that when that trace of actions is projected to size $n$ it also has all the required actions. 

The intuition for this lemma is that the actions that are projected out are precisely the actions that are no longer required for the smaller system. The proof examines each type of action that is required and shows that action is also required in the larger system. This implies that the action exists in the original list. We then show that that action remains in the list after the projection.

\begin{lemma}{has\_no\_duplicate\_receives\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \hndr{A} \longrightarrow \\
\hndr{\projectsize{A}{n}}
\end{multline*}
\end{lemma}
This lemma proves that if a trace of actions does not have more then one receive to the same destination of a given type that implies that when the list is projected to size $n$ it still has no duplicates.

This is proven by induction on the trace of actions, with the core intuition being that the projection can not introduce any new actions. This is proven in the sublemma \emph{not\_in\_orig\_not\_in\_proj}. This intuition is proven by showing that if it were the case that the projected trace of actions had a duplicate where the original trace did not this leads to a contradiction. 


\begin{lemma}{valid\_implies\_all\_receives\_causal\_in\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \actsvalid{A}{n+1} \longrightarrow \allrc{\projectsize{A}{n}}{n} $$
\end{lemma}
This lemma is the least trivial and the core problem that needed to be proven to show that the larger system conforms to the smaller system. The receive causality property is difficult because an send action that is associated with a given receive prior to the projection may be removed in the projection. However, if the send for a receive is projected out there is an equivilant send from the previous node that now can be matched with that receive. 

This lemma is proven by careful case analysis. The proof itself spans nearly 500 lines and makes use of information known about the trace of actions based on the \emph{acts\_valid} assumption. 

The \emph{all\_receives\_causal} property asserts that for all possible actions, if that action is a receive and it is in the trace of actions that implies that there must exist an action that is the associated send for that rceive, that send must be in the trace, and that send must happen before the receive. 

We begin by introducing an action $r$ which is the receive in question. We assume it exists in the projected list and that it is indead a receive and use the sublemma \emph{in\_proj\_in\_orig} to show that the action must also appear in the original trace. 

With the knowledge that the action was in the original trace the assumption of the validity of the original trace allows us to show that there must be a corresponding send for that receive in the orignal trace. 

We now know that there is a recieve that is both in the original trace and in the projected trace, and that there is a corresponding send in the original trace. From here we examine the posible scenarios for what happens to the corresponding send in the projection.

These scenarios are:
\begin{enumerate}
\item \label{case:normal} Both are unchanged. Neither the send nor the receive are removed and neither \emph{wrap} around in the modulus.
\item \label{case:src_wrap} The send alone is projected out. The source of the send refers to a node that is no longer in the system the original send is projected out.
\item \label{case:dest_wrap} The send destination alone is projected out and the send now \emph{wraps}.
\item \label{case:both_wrap} Both the send source and the send destination refer to a node that is removed. 
\end{enumerate}


Scenario \ref{case:normal} is pretty straightforward, the send for the receive is the exact same send as in the original trace. We just show that the send remains in the projection.

Scenario \ref{case:src_wrap} is tricky. The previous associated send is projected out. But the recieve is not projected out. To prove this scenario we use information about the required actions in the original trace. After unpacking this information we can show that there must be a send that would have gone to the node that was projected out. We show that this send \emph{wraps} due to the change in the size in the modulus which means that that send is now associated with the receive in question.

Scenario \ref{case:dest_wrap} is the dual of scenario \ref{case:src_wrap}. The same problem but from the other perspective. This is the case where a node that is not projected out sends to a node that is projected out. We show that that message \emph{wraps} to connect with a new recieve which is our receive in question. %THIS EXPLAINATION FEELS OFF. DOUBLE CHECK THIS

Scenario \ref{case:both_wrap} is an interesting case because it is only possible if we project out more then one node in a single step. The way the property is defined this is not possible because we have a system that is valid for size $n+1$ that is projected to size $n$. It takes some mathematics and a few properties about modular arithmatic to show that this case is imposible and always leads to contradictions.

There is one final scenario in the proof not listed above. It is the case where the destenation of the receive is projected out. This comes out as an implementation detail for how we obtained some information about the original destination. We assumed that the original destination was either less then the new size or greater or equal to it. Then we checked each case. The case where the destination was greater or equal to the new size is easily dismissed by noting that that would mean that the recieve that needs a send was projected out, which is a contradicition with the assumption that it is in the projected trace.

Once each of these cases were individually proven or shown to lead to contradictions the property proves out.

\begin{lemma}{all\_sends\_triggered\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allst{A} \longrightarrow \allst{\projectsize{A}{n}} $$
\end{lemma}
This lemma shows that if \emph{all\_sends\_triggered} holds in the original system it continues to hold in the projected system. This property enforces a partial order of events.

The intuition of this proof is that projections don't affect the order of events. This is proven concretely in the sublemma \emph{happens\_before\_independent\_of\_proj} which us used several times in this proof. 

\begin{lemma}{all\_ids\_in\_range\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allir{A}{n+1} \longrightarrow \allir{\projectsize{A}{n}}{n} $$
\end{lemma}
This lemma proves that there are not any actions associated with nodes that would not be present in a system of the given size. It can be directly poven based on the definition of \emph{projected}. 

\begin{lemma}{promise\_forward\_commit\_backward\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \pfcb{A} \longrightarrow \\
\pfcb{\projectsize{A}{n}} 
\end{multline*}
\end{lemma}
This property requires that the source and dest feilds in Send actions follow certain patterns. The intuition if this proof is that projection does not mutate fields. We simply show that the projected item must have been in the original list and this property holds on the action in the original list. Because it has not changed this property holds in the projected list.

\begin{lemma}{phase\_sequence\_correct\_independent\_of\_proj}
\begin{multline*}
\forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \psc{A} \longrightarrow \\
\psc{\projectsize{A}{n}}
\end{multline*}
\end{lemma}
This property also imposes a partial order on traces. It is proven similar to \emph{all\_sends\_triggered\_independet\_of\_proj}, by showing that projections don't effect the order of events using the sublemma \emph{happens\_before\_independent\_of\_proj}. 

\begin{lemma}{all\_ref\_recieves\_causal\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N}, n > 2 \wedge \allrrc{A} \longrightarrow \allrrc{\projectsize{A}{n}} $$
\end{lemma}
This property requires that if a node receives a message from the referee it first sent a message to the referee. The intuition of this proof is that if a SendRef action that requested the status from the referee is projected out that implies that the ReceiveRef action is also projected out.

\begin{lemma}{not\_in\_orig\_not\_in\_proj}
$$ \forall A \in \listaction\ a \in \action\ n \in \mathds{N}, a \notin A  \longrightarrow a \notin \projectsize{A}{n} $$
\end{lemma}
This lemma shows that if an action is not in the original trace of actions it cannot be in the projected trace of actions. It is proven by induction on the trace of actions. It uses a proof by contradiction. We assume that the action is not in the original list but is in the projection. Then using the lemma \emph{in\_proj\_in\_orig}, we show that it must also be in the original list. This contradicts our first assumption.

\begin{lemma}{in\_proj\_in\_orig}
$$ \forall A \in \listaction\ a \in \action\ n \in \mathds{N}, a \in \projectsize{A}{n} \longrightarrow  a \in A $$
\end{lemma}
This lemma shows that if an action exists in the projected system then it must have existed in the original system. In other words, projection does not introduce new actions.
 It is proven by induction on the list of actions. The base case with an empty list easily leads to a contradiction. Then when considering a single action use the definition of \emph{project\_to\_size} to show that the action must have come from the original trace. 

\begin{lemma}{happens\_before\_independent\_of\_proj}
$$ \forall A \in \listaction\ n \in \mathds{N},
a\ b \in A \wedge a\ b \in \projectsize{A}{n} \wedge a \happensbefore b \longrightarrow a \prec_{\projectsize{A}{n}} b
$$
\end{lemma}
This is the core lemma showing that projection doesn't reorder actions in the trace. It is proven by induction on the trace of actions. The base case with an empty trace is easily dismissed with a proof by contradiction. 
Then when we consider a list of actions with one additional action prepended to the list. We call this new action $a$. On this new list we know that the action $x$ happens before the action $y$.
We can examine what might happen to $a$ in the projected trace.
Using the sublemma \emph{projected\_in\_or\_out} we know that an action either remains in the projected trace or is removed entirely from the projected trace.
We will consider both of these cases.
If $a$ remains in the list then it becomes the first item in the list. 
We then consider the possible cases for what $a$ is.
$a$ could be equal to $x$, it could be equal to $y$, or it could be neither $x$ nor $y$.
If it is equal to $x$ then because it is the first item in the list it must happen before $y$.
If it is equal to $y$ it means that $y$ must happen before $x$, however, $a$ is also the start of the unprojected list so we can show that that is a contradiction with our assumption that $x$ happens before $y$.
If it is either $x$ nor $y$ then it does not have any bearing on whether $x$ happens before $y$ or not. We can then consider the rest of the list to check that $x$ happens before $y$ in the sublist. This reduces the problem down to our inductive hypothesis.
Finally, we must consider the case where $a$ is removed from the list in the projection. This immediately reduces to the inductive hypothesis which allows us to prove that the \emph{happens\_before} property is independent of projection.

\section{Extending the model-checking results using the inductive proof}
With the results presented in Section \ref{chap:model_checking_results} and Section \ref{chap:coq_results} we have shown that the desired properties hold for a small system and that an arbitrarily large system can be projected to a 3-node base system. We observe the possible set of inputs and outputs of each node in the base system are unchanged regardless of the size of the system. 

To extend the model checking results to a large system we can use Trace Theory as described by Dill. Trace theory considers when it is safe to substitute one module for another. If for any given context (a set of possible inputs) a replacement module generates the same set of possible outputs, then the replacement module can be swapped out for the original without affecting the behavior of the rest of the system \cite{dill_trace_theory}. This logic is mirrored in the Liskov Substitution principle. If the set of accepted inputs to a replacement module is at superset of, or equal to of the set of accepted inputs in the original, and if the set of possible outputs of a module is a subset of, or equal to the set of possible outputs of the original, then it can be safely swapped out \cite{liskov_substitution}. 

The validity rules checked by the inductive proof assert that some properties of the inputs and outputs of each node are invariant on the size of the system. Each rule as defined in Section \ref{sec:validity_rules} takes the form of $ \forall n \in \mathds{N}, P(n)$ Where $P(n)$ is some predicate that makes claims about the inputs and outputs of the node with ID $n$. By examining the outputs of a node preceding a target and the inputs of a node following a target we can identify the allowable inputs and possible outputs of that target.

Consider a target that is a single node with identifier $i \in \mathds{N}, 0 \le i < S$. The actions in the trace that are inputs for $i$ are those of the form:
\begin{enumerate}
    \item  $(Send, s, i, m)$
    \item  $(Receive, i, m)$
    \item  $(ReceiveRef, i)$
\end{enumerate}
The actions in the trace that are outputs for $i$ are those of the form:
\begin{enumerate}
    \item  $(Send, i, d, m)$
    \item  $(SendRef, i)$
\end{enumerate}

The validity rules provide restrictions on the form the inputs must take. For example, the rules specify that $(Receive, i, Promise)$ must be present. It also specifies that  $(Send, i-1, i, Promise) \happensbefore (Receive, i, Promise)$. The validity rules also provide restrictions on the form that the outputs must take. For example, they specify that if the input does not include $(Send i+1, i, Commit)$ that the output must include $(SendRef, i)$ must be in the trace. In this way the rules constrain the allowable inputs and the possible outputs of the given node.
Consider now a chain of relay nodes with IDs $(i, i+1, ..., j-1, j), 0 \le i < j < S$ We can note that---according to the validity rules--- the inputs to this chain of nodes are equivalent to the inputs to $i$, and the outputs to this chain of nodes are equivalent to the outputs of $j$. 

So the inputs and outputs of a single node or a chain of N nodes are equivalent. The proof described in Section \ref{chap:coq_results} also proves that the inputs and outputs of each node are invariant on the size of the system. Because these inputs and outputs are equivalent, by either trace theory, or the Liskov substitution principle, this implies that no matter the size of the system, a chain of N nodes can be substituted for a single node without affecting the behavior of the rest of the system.

This is clearly true as defined in the inductive proof, however, can this be used to show that a chain of nodes can replace a single node in the Spin system? In other words, can we replace a single node in the Spin model with a chain of N nodes as defined in the inductive proof?

For this to be provably correct two conditions must be met:
\begin{enumerate}
    \item The chain of N nodes defined in the proof can accept all possible outputs that could be generated by the Spin model.
    \item The possible outputs of the chain of N nodes are inputs that were considered in the Spin model. 
\end{enumerate}

If these conditions are met then the chain of N nodes be substituted safely in the spin model. Section \ref{sec:inputs_smaller} discusses how the Spin model was adjusted to verify the first condition. Section \ref{sec:outputs_bigger} argues that the second condition holds.

\subsection{Constructing a verified large system}
There is one final consideration: The desired properties have not been verified on the chain of N nodes used as a replacement module. However, the properties have been verified on the other nodes in the now larger system. To ensure that the properties hold for every node in the larger system we must show that the large system can be constructed such that any node in the large system is not replaced. 

This is fairly simple to accomplish. For example, if we would like to leave the 7th node in a 15-node system unreplaced, we can choose to replace the originator with a chain of 6 nodes (including a new node with ID 0 to act as the originator). We then leave the first relay node in place as our desired 7th node. Then we replace the second relay node with a chain of 8 nodes. We know that those substitutions are safe substitutions so we can show that the properties hold for the 7th node in the system. Using a similar process we can show that any node in the system can be left unreplaced. Thus we know that the properties hold for every node in a system of arbitrary size. 

\section{The inductive proof accepts all model-checking outputs}
\label{sec:inputs_smaller}
Consider the set of inputs allowable by the validity rules, ($C$), and the set of outputs that can be generated by the Spin model ($S$). We must show that $S \subseteq C$ to ensure that the replacement module can accept all of the inputs it would experience in the Spin model. If $S \nsubseteq C$ then there must exist a trace explored by Spin that breaks the validity rules. By encoding the validity rules as properties in Spin, we can then verify that the rules hold for all of the traces evaluated by Spin. 

To implement the properties to match the Coq rules the Spin model needed to be extended to generate a data structure that recorded the trace of actions. This data structure is referenced in the new properties to verify the rules about traces hold. Because the actions considered in Coq are all inputs and outputs of nodes, to generate this trace of actions it was only necessary to adjust the helper functions that send messages and then add a few lines to add actions to the trace when a message is received. 

After making these adjustments the validity rules can be written in Spin as properties, then Spin will evaluate each trace of events to ensure that the properties hold. 

When Spin verifies these properties it produces some counter-examples which we would like to exclude. These counterexamples are cases where---because messages are lost---a \promise message does not reach each node. This violates the \emph{has\_required\_actions} rule. However, these traces would be valid for a system of size smaller than 3. Because we are interested only in mapping the Coq proof to the spin model for the base system, we want to introduce a new fairness property that eliminates cases that represent systems smaller than the base system. This property requires that each node eventually leave the \emph{no\_lift} state. After triggering on this fairness property, each of the validity rules was successfully verified to hold for all traces evaluated by Spin. 

Similar to the previous fairness property we added a check to ensure that the new \emph{of\_size\_3} property is achieved. This check passes.

These results verify that $S \subseteq C$. Because of this, we know that the chain of N nodes can accept all possible outputs of the Spin model. 

\section{The model checker accepts all inductive-proof outputs}
\label{sec:outputs_bigger}
The set of all combinations of outputs for a chain of N nodes grows exponentially with the size of N, however, these outputs fit into a small set of equivalence classes. 

\begin{enumerate}
    \item The case where no Promise message is sent
    \item The case where a Promise is sent but no Commit is sent
    \item The case where a Promise and a Commit is sent
    \item Each of the previous cases where 1 or more messages are also sent to the Referee
\end{enumerate}

We can evaluate if each of these equivalence classes is considered in the Spin model by generating a property that asserts a trace of that class is not present. If all of these properties fail, then we know that each equivalence class is accepted by the Spin model.
\krs{Add this to the mapping spin model. And add results here}

\section{Related Work}
\krs{Need to add sections about other results that use conformance, as well as infinite state model checking}
There are numerous bodies of work that solve similar problems or utilize similar constructs. The following list is particularly relevant. 
 
 Nakamoto describes how transferable digital tokens can be double-spent. The paper introduces bitcoins and describes the proof of work method of overcoming this problem which is often referred to as blockchain technology. \cite{bitcoin} 

 Bateman recognizes that the double spending problem is present only in digital currencies that are both duplicatable and transferable. Blockchain technology prevents digital tokens from being duplicated. MyCHIPs instead is designed with non-transferable tokens. MyCHIPs utilizes credit lifts to allow these non-transferable tokens to be virtually fungible and to allow for effective transactions to be made. 
 
 Huang, Ogles, and Mercer prove that \emph{doesn't commute}, a weakened version of the happens-before relation, is sound for certain common classes of task parallel programs. They present a mechanized proof that proves properties for all traces constrained by a partial order. The methods demonstrated by Huang, Ogles, and Mercer can be utilized in this work's mechanized proof that the larger system conforms to the behavior of the smaller system. \cite{ben_DC}

 Bhargavan et. al. Verify Smart Contracts \cite{SmartContracts}. Smart contracts are a type of distributed computation where the program that is executed is secured in a blockchain. While not directly related, smart contracts have the same financial stakes MyCHIPs have and some of their techniques could give inspiration.  Bhargavan et. al, translated the smart contract code into a functional programming language, F*, aimed at verification. This allowed for contract verification based on F* type-checking.
 
 
 Fischer, Lynch, and Paterson,\cite{Fischer} prove the impossibility of consensus on even a Boolean, with even one faulty (or malicious) process. However, this is only true if the processes don't have synchronized clocks. This proof shows the necessity of the referee with strong reachability requirements for the lift algorithm to always eventually reach a consensus on if the lift should commit or be nullified.
 
 
 Schneider summarizes and frames many fault-tolerant distributed algorithms in the framework of  machines\cite{StateMachine}. He shows how many common algorithms are isomorphic to, and can be derived using, the state machine approach. It is a helpful method to characterize and compare different approaches.
 
 Lamport\cite{Lamport}, describes a refinement process that takes a distributed fault-tolerant consensus algorithm and hardens it to be tolerant of byzantine actors through a process he calls \emph{byzantizing.} This method may be useful in future work to ensure the MyCHIPs pr=otocol follows key principles of Byzantine hard protocols.
 
 Delzanno, Tatarek, and Traverso, model check a common consensus algorithm called Paxos in Spin. Their spin constructs provide helpful examples of how distributed algorithms are efficiently modeled.\cite{Delzanno_2014}
 
 Konnov, Veith, and Widder explore the unsolved problems associated with model checking distributed algorithms. This can serve as a hazard map of difficult unsolved problems. It would be unfortunate if solving a known problem that is tangential to this work becomes a prerequisite to finishing. This also can serve to give context to this work and show how it progresses towards solving some of these problems.\cite{Konnov}

%%
%% If your work has an appendix, this is the place to put it.
\appendix

\section{The MyCHIPs system}
\label{apdx:mychips}
The MyCHIPs protocol and the methods used to verify it can be understood independently of the system it is used in. However, the curious reader will want to know more about the context in which the MyCHIPs protocol operates. This section provides an overview of the system. More details can be found on Kyle Bateman's website \cite{bateman_myCHIPs}. 
In particular, this section will cover the common challenges with using digital currency, how existing systems overcome those challenges, and how MyCHIPs overcomes those challenges in a unique way that provides additional benefits. 

\subsection{The two types of Money: Commodity and Credit}
The purpose of money is to be a medium of exchange, and it does so by storing value. When someone provides a good or service, the seller is usually given money in exchange. This money stores the value they provided until the seller is ready to redeem that value to get something they need.
For this to work, whatever is used as money needs to be considered valuable. There are two prevailing methods for accomplishing this: commodity money, and credit money. 

In this context, a commodity is anything that can be owned and that can have its right to ownership transferred from one party to another. A commodity derives its value from the economic laws of supply and demand. Because some commodities are consistently desired and are sufficiently scarce, their value is stable enough to be used as money. For example, gold has historically seen widespread use as commodity money. As long as a commodity is in demand and its supply is reasonably limited, it can likely be used as money.

In contrast, credit money exists as a promise from one party to another of future value--likely a commodity or service. If the party giving the promise is trustworthy, the credit money has value equal to what was promised.
%If not, such pledges may be secured by collateral, which is a promise of ownership of an existing commodity should the pledgor fail to deliver on the promise of future value. 

\subsection{Digital Currencies}
Most digital currencies, including Bitcoin and Ethereum \cite{bitcoin}, take the commodity money approach. This decision led to two key technical challenges: achieving scarcity, and community consensus on ownership.

\paragraph{Achieving Scarcity}
It can be difficult to make a digital object that can be kept scarce.
Physical commodities, such as gold, are difficult to locate and refine. To mirror this difficulty of discovery, a finite set of digital tokens can be mathematically defined in such a way that they were not known specifically in advance. However any token, once discovered, could be easily checked to determine if it belonged to the set. Furthermore, discovering tokens is often computationally complex enough that it requires significant time and energy to discover a new token. This allows for a commodity that is both digital and scarce.
There are many possible sets that could be used, however, hash functions and blockchains became the prevailing method because using this method simultaneously solves the community consensus problem.

\paragraph{Community Consensus}
For someone to transfer ownership of a commodity, it is important for them to be able to prove that they own the commodity. Because of this, using commodity-based money requires community consensus about who owns what commodities.

Community consensus can be difficult to achieve, especially when many malicious actors may be present. One frequently discussed example where community consensus is not successfully achieved is the \emph{double-spending} problem. \emph{Double spending} is a difficult challenge and efforts to solve the problem lead to the development of blockchain algorithms. 

\subsection{Double-Spending}
Double spending is a challenge that arises when using digital commodities as currency. To spend a commodity-based digital token, an entity must send a transmission that convinces a peer that it owns a digital token and is transferring ownership of that token to the peer. However, if the entity can send one transmission that fulfils this, it can easily send the same transmission to two peers simultaneously. If the peers have no means of communicating with each other (or some third party) then they each have no reason not to accept the digital currency. This allows a malicious actor to “double-spend” a digital token.

\subsection{Overcoming Double-Spending with a Public Ledger}
Most commodity-based digital currencies overcome the double-spending problem is using a public ledger. With a public ledger, each transaction between any entities using the digital currency must be stored in a single public record. By using a public record, double-spending can be identified and prevented. This public ledger may be implemented by assigning a central trusted authority to manage the ledger or it may use a decentralized ledger with a consensus algorithm. 

While using a central trusted authority to manage the ledger is simple, its centralized nature leads to certain risks. First, the central authority is a single point of failure. If the central authority experiences some error and is not able to process transactions for a period of time, all trade using the digital currency would halt. Second, giving the central authority control over all the transactions of a digital currency requires great trust in the authority. The central authority could easily falsify records in order to benefit itself or a third party. In practice, there is not a single authority that every potential user of a digital currency will consider worthy of that amount of trust.

Using a decentralized ledger removes the need for a single trusted authority, but steps must be taken to ensure that the ledger cannot be falsified by an attacker and that a quorum of users eventually agrees on the state of the public ledger. There are two common consensus algorithms used to achieve this: proof-of-work, and proof-of-stake.

\subsubsection{Proof-of-Work}
Proof-of-work consensus algorithms allow for a form of democratic consensus where the group that holds more then 50\% of the computational resources decides the state of the public ledger. The blockchain method accomplishes this by requiring each block to include a partial hash collision. Such a collision will includes a certain number of leading zeros in the result of the hash. Because cryptographic hash functions are designed to be unpredictable and non-reversible, there is no inverse function to compute what data must be added to a record to get the required hash. In order to add a block of data to the ledger an entity must compute many billions of hashes until it finds a partial collision. These blocks are then chained together so the hash of the previous block is included in the next block. 

By chaining these blocks together in order to make a change to a previous block that appears legitimate an attacker must recompute the hash collision for all subsequent blocks. If the attacker does not have more then 50\% of the computation power they won't be able to compute the required hashes faster then the block chain grows and will never be able to make a falsification appear legitimate.

This method has been quite successful at accomplishing its goals, but it has received criticism from the economic and environmental impacts it causes. In order to maintain security of the public ledger the computation work required needs to be great enough to prevent attacks, however computational work is not free. There is very large overhead to purchase and maintain equipment and supply power to be able to complete the computational puzzles required by proof-of-work. This means that transaction costs for block-chain currencies are much higher then traditional transactions. Additionally, the power used for proof-of-work often is generated by burning fossil fuels, which contributes to greenhouse gas emissions and depletes limited resources. Many argue that proof-of-work consensus algorithms are not sustainable. 

\subsubsection{Proof-of-Stake}
In response to these criticisms, algorithms have been implemented that rely on \emph{proof-of-stake} rather then proof of work. Proof-of-stake algorithms rely on similar principles as proof-of-work but rather then allowing anyone to complete the computational puzzle, validators are randomly selected from a pool. To become a validator an entity must place sufficient stake as collateral. If they are found to behave maliciously, their collateral is forfeit. This allows the computation puzzles to be set to be much easier to solve which in turn reduces the overhead and environmental impact of transactions.

\subsubsection{Public Ledgers and Privacy}
Both proof-of-work and proof-of-stake algorithms operate to create consensus on a single, public ledger. The requirement for a public ledger means that no transactions can be made privately. Steps can be taken to attempt to anonymouize transactions but if the identifiers used in the transaction are connected with the individuals they represent, anyone can see the entire history of that person's transactions. Additionally, requiring a consensus on a single public record limits how decentralized the digital currency can be. Because of the privacy concerns, the economic and environmental impact of blockchain transactions, and to make a more decentralized monetary system, an non-blockchain digital currency is desirable. MyCHIPs aims to serve as a credit-based digital currency that avoids these fundamental problems. 

\subsection{Private Credit Digital Currency}

Transferability is intrinsic to commodity money. If you cannot transfer ownership of the commodity you can't transfer the value and it doesn't work as money. Credit money however can be made non-transferable and still maintain value. The promise for goods or services connected with the credit money can be valuable even if that promise is valid only for you. Making tokens non-transferable solves many security problems but leads to other practical problems.

\subsection{Solving the double-spending problem with non-transferability}
To prevent double spending we must ensure that a malicious actor gains no benefit from transferring a digital token to two different peers. Rather then preventing duplication, MyCHIPs instead ensures that tokens are only transferred once. To meet this goal, tokens in the MyCHIPs system are designed to be non-fungible and non-transferable. A token is created for a single recipient and is valid for only that recipient. However, this method has an obvious problem: how does one spend a non-fungible, non-transferable token? MyCHIPs has a method to make CHIPs \emph{virtually fungible} that involves giving the CHIPs back to the issuer in a distributed algorithm called a credit lift.  \cite{bateman_myCHIPs}


\subsubsection{The value of a CHIP}
As mentioned above, blockchain based cryptocurrencies rely primarily on scarcity to drive their value.
Experience has shown how this results in highly volatile valuations over time.
Volatility may be useful in certain investments, but it is generally not desirable in a currency.

In the same way that bonds tend to be less volatile than stocks, a credit-based currency will be more stable than one based on a purely demand-driven commodity.
However, the credit lift algorithm does rely on the assumption that at each stage of the lift, parties are trading tokens that have a uniform nominal value.

This unit of measure is called the CHIP--a clever backronym for Credit Hour in Pool.
The value of a CHIP is defined to be the value of one hour of unskilled labor. Parties agree to this definition in a digital contract when they issue CHIPs. Recent research has placed this value at \$2.53. \cite{bateman_chip_value}

However, if a laborer is providing tools, or has some expertise in the work they may be able to negotiate receiving more than one CHIP for an hour worth of work.
That is up to the market to decide.
The CHIP definition only quantifies what is being promised with the issuance of each new CHIP.

Unfortunately, it is not very common where the seller of a good wants something directly from the buyer in exchange. To make MyCHIPs useful to facilitate trade the seller needs to be able to use the CHIPs to get goods or services from other entities besides the buyer. This is accomplished through a \emph{credit lift} (hereafter, \emph{lift}).

\subsection{Chits and Tallies}
Because a Token in the MyCHIPs is only valid between exactly two entities, these tokens only need to be tracked by those two entities. These tokens are tracked on a consensed record called a \emph{Tally}. A \emph{Chit} is an atomic transaction where one or more CHIPs are given to the partner. A Tally is an ordered collection of Chits with additional information to note the terms of the two entities agreement. 

Whenever a pair of entities desires to establish a trade relationship with each other, they create a new Tally to track that relationship. Most trade relationships are fairly consistent about who is selling goods or services and who is buying. When creating a Tally the entities establish this normal flow by assigning the entity who is usually paid and provides goods the \emph{Stock} role in the Tally, and the one who usually pays the \emph{Foil} role. These names hearken to a traditional method of tracking such credit relationships called a \emph{Split Tally}. If the entity that takes the \emph{Stock} role wishes to purchase goods or services from the \emph{Foil} entity, the entities create a new Tally with the roles reversed.

Each time a transaction is made, the entity with the Foil role creates a Chit that includes: 
\begin{enumerate}
    \item The number of CHIPs being sent
    \item A verifying digital signature
    \item The date and time of the transaction
    \item Other metadata about the transaction
\end{enumerate}
The verifying signature could be either the signature of the entity with the Foil role or as described in section \ref{sec:liftAlgorithm} the signature of the referee if the transaction is part of a credit lift. The verifying signature is all that is needed for one entity to prove the other owes some debt, however, it is helpful for both entities to have assurances that they are in agreement about the balance of their tally. 

To ensure that both entities agree on the state of the Tally, they exchange hashes of their Tally. If the hashes match they can be assured they are in agreement on both the Chits in the tally as well as the order of those Chits. If there is a mismatch, the consensus algorithm is simple: the Tally of the entity with the Foil role is considered correct. If there are still missing Chits, the entity with the Stock re-transmits those to the Foil. The Foil adds those Chits to the Tally and re-transmits its new hash. 

\subsubsection{The MyCHIPs Credit Lift}
A lift makes CHIPs \emph{virtually fungible} by identifying a circuit where every entity holds CHIPs issued by their predecessor in the circuit. The lift algorithm arranges for each entity in the cycle to forgive the debt of their predecessor to get the same amount forgiven by their successor. 
 
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{ExampleCircuit.png}
    \caption{Example Circuit}
    \label{fig:liftProt}
\end{figure}
How this facilitates trade can be better understood by considering a barter system that involves more than two parties. 
For example, Bob needs his car fixed, John wants solar panels installed on his roof, and Cindy wants a well dug. Cindy knows how to fix cars, Bob knows how to install solar panels, and John is able to dig a well. See Fig. \ref{fig:liftProt} for a graphical representation of this arrangement. If they get together, they can work out a trade where John digs the well for Cindy, Cindy fixes Bob's Car, and Bob installs John's solar panels. Everyone would be happy.

But it is difficult to identify the these cycles before every transaction. This is where money comes in. Using government-backed money like dollars or euros, the process for enabling this transaction might go as follows:
\begin{enumerate}
\item Bob gets a loan from a bank
\item Bob uses the money from the loan to pay Cindy to fix his car.
\item Cindy gives that money to John to dig the well
\item John gives Bob the money to install the solar panels
\item Bob uses the money to repay his loan (but he may need to pay a little 
interest).
\end{enumerate}

MyCHIPs solves the same problem but instead does so by explicitly finding these cycles of value. Each person providing goods or services accepts CHIPs as an IOU for the exchange. Then a successful lift discovers this cycle of value and clears the debts of all involved.

If John, Bob, and Cindy were to use a credit lift to facilitate the arrangement it would go as follows:
\begin{enumerate}
\item Bob asks Cindy to fix his car and agrees to give Cindy 10 CHIPs 
\item Cindy gives John 10 CHIPs to dig the well
\item John gives Bob 10 CHIPs to install the solar panels
\item Cindy talks with Bob and learns that John gave Bob 10 CHIPs
\item Cindy realizes that Bob gave her 10 CHIPs, she gave John 10 CHIPS and John gave Bob 10 CHIPs. There is a cycle!
\item Cindy initiates a lift and \emph{promises} Bob that she will forgive his debt if he can get John to do the same for her. By doing this she takes on the role of the \emph{originator} of the lift. 
\item Bob gives John a similar promise.
\item John gives Cindy a similar promise and Cindy knows the deal is on.
\item Cindy \emph{commits} and gives Bob 10 CHIPs to cancel his debt
\item Bob gives John 10 CHIPs
\item John gives Cindy 10 CHIPs
\end{enumerate}
Everyone's tally for how many CHIPs they have given each other now totals to 0.
We can see this exchange allows for virtual fungibility: each person trades some CHIPs they have received to get back some CHIPs they have given out. 
This resets their balances so they can then give more CHIPs out again in exchange for future goods they will need. 

\section{Details of Coq Definitions}\label{apdx:coq_detail}

\paragraph{has\_required\_actions}
The has\_required\_actions rule is designed to check that the set of traces has all of the actions required by the protocol for a system of a given size. There are two sections to this rule that correspond with the promise and commit phase of the protocol. 

For the promise phase, we ensure that each node in the system receives and sends a promise message. In a real system, some messages may be lost which would cause some nodes to not receive a promise message, however, these cases can be considered to be a system of size $n$, where $n$ is the number of nodes who did receive a promise message. 

For the commit phase, we define a failure point $m$. Each node after $m$ may not receive a commit message and must send a status request to the referee. Each node before $m$ must receive a commit message. This failure point is an important construct for some of the required lemmas to prove the main theorem. To maintain this, a real system must not forward a signature obtained directly from the referee. 

The has\_required\_actions rule enforces a minimum requirement for actions that must be present in the trace, additional actions are permitted.

\paragraph{has\_no\_duplicate\_receives}
The has\_no\_duplicate\_receives rule is designed to check that is only one Receive action for each destination and message type. This rule simplifies the \emph{all\_receives\_causal} rule by allowing it to require only that there exists a corresponding send that happens before. Without this rule it would be necessary to match a corresponding send with each receive to ensure that one sent message is not received twice. This would make the proof much more complex. It is a property about how traces should be recorded. A real system must ensure that all responses to a message are idempotent or that duplicate received messages are ignored. 

\paragraph{all\_receives\_causal}
The all\_receives\_causal rule is designed to check that each receive is preceded by a corresponding send. To define this rule we define \sloppy \emph{is\_send\_for\_receive} which given two actions evaluates if the first is a Send and the second is a receive such that the destination of the send is equivalent to the destination of the receive. The equivalent here is defined as equal modulo the size of the system. This allows for messages that \emph{wrap} around the cycle to be considered equivalent without the need to mutate actions during projection. 

We also define a happens\_before function which evaluates to true only if the first action given occurs earlier in the list then the second action. 
Using these two definitions we can check to ensure that every Receive action is preceded by a corresponding send. 

\paragraph{all\_sends\_triggered}
The all\_sends\_triggered rule is designed to check that only the originator sends a message without first receiving a message that triggered that action. This rule again uses the \emph{happens\_before} function to check that that the triggering message is received before the triggered message is sent. 

\paragraph{all\_ids\_in\_range}
The all\_ids\_in\_range rule enforces the size of the system. It defines the allowable values for IDs in source and destination fields. All source fields must be a integer greater or equal to 0 and less then the size of the system. All destination fields can be up to one ID beyond the limit to allow for wrapping. This allows for destinations to be integers greater or equal to -1 and greater or equal to the size. However, messages received from the referee never wrap so they have the same rules as source fields. This property is necessary to identify and discriminate some invalid cases in some Lemmas. 

\paragraph{promise\_forward\_commit\_backward}
The promise\_forward\_commit\_backward rule enforces that promise messages are sent only to successors in the cycle, while commit messages are sent only to predecessors in the cycle. This rule also enforces that if a message wraps around the destination id must be greater then the size or less than 0 rather than using the equivalent id within range. This allows for wrapping messages to easily be identified and preserves monotonicity.

\paragraph{phase\_sequence\_correct}
The MyCHIPs lift protocol operates in two distinct phases, the promise phase, and the commit phase. The phase\_sequence\_correct rule enforces that the originator initiates these phases with the Promise phase first and the commit phase second. This property helps to discriminate invalid situations in some Lemmas.

\paragraph{all\_ref\_receives\_causal}
The all\_ref\_receives\_causal rule is similar to all\_receives\_causal but is is connected with messages to and from the referee. Because there is no need for destination ids to wrap this property is easier to define and prove. 

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{splncs04}
\bibliography{krs_thesis}


\end{document}
\endinput
%%
%% End of file `sample-acmtog.tex'.
