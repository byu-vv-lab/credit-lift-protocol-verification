
@inproceedings{Fischer,
author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
title = {Impossibility of Distributed Consensus with One Faulty Process},
year = {1983},
isbn = {0897910974},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/588058.588060},
abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. We show that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the "Byzantine Generals" problem.},
booktitle = {Proceedings of the 2nd ACM SIGACT-SIGMOD Symposium on Principles of Database Systems},
pages = {1–7},
numpages = {7},
location = {Atlanta, Georgia},
series = {PODS '83}
}
@inproceedings{SmartContracts,
author = {Bhargavan, Karthikeyan and Delignat-Lavaud, Antoine and Fournet, C\'{e}dric and Gollamudi, Anitha and Gonthier, Georges and Kobeissi, Nadim and Kulatova, Natalia and Rastogi, Aseem and Sibut-Pinote, Thomas and Swamy, Nikhil and Zanella-B\'{e}guelin, Santiago},
title = {Formal Verification of Smart Contracts: Short Paper},
year = {2016},
isbn = {9781450345743},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/2993600.2993611},
abstract = {Ethereum is a framework for cryptocurrencies which uses blockchain technology to provide an open global computing platform, called the Ethereum Virtual Machine (EVM). EVM executes bytecode on a simple stack machine. Programmers do not usually write EVM code; instead, they can program in a JavaScript-like language, called Solidity, that compiles to bytecode. Since the main purpose of EVM is to execute smart contracts that manage and transfer digital assets (called Ether), security is of paramount importance. However, writing secure smart contracts can be extremely difficult: due to the openness of Ethereum, both programs and pseudonymous users can call into the public methods of other programs, leading to potentially dangerous compositions of trusted and untrusted code. This risk was recently illustrated by an attack on TheDAO contract that exploited subtle details of the EVM semantics to transfer roughly \$50M worth of Ether into the control of an attacker.In this paper, we outline a framework to analyze and verify both the runtime safety and the functional correctness of Ethereum contracts by translation to F*, a functional programming language aimed at program verification.},
booktitle = {Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security},
pages = {91–96},
numpages = {6},
keywords = {smart contracts, formal verification, ethereum, EVM, solidity},
location = {Vienna, Austria},
series = {PLAS '16}
}

@article{StateMachine,
author = {Schneider, Fred B.},
title = {Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial},
year = {1990},
issue_date = {Dec. 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {4},
issn = {0360-0300},
doi = {10.1145/98163.98167},
abstract = {The state machine approach is a general method for implementing fault-tolerant services in distributed systems. This paper reviews the approach and describes protocols for two different failure models—Byzantine and fail stop. Systems reconfiguration techniques for removing faulty components and integrating repaired components are also discussed.},
journal = {ACM Comput. Surv.},
month = dec,
pages = {299–319},
numpages = {21}
}

@InProceedings{Lamport,
author="Lamport, Leslie",
editor="Peleg, David",
title="Byzantizing Paxos by Refinement",
booktitle="Distributed Computing",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="211--224",
abstract="We derive a {\$}3f{\backslash}!+{\backslash}!1{\$}process Byzantine Paxos consensus algorithm by Byzantizing a variant of the ordinary Paxos algorithm---that is, by having {\$}2f{\backslash}!+{\backslash}!1{\$}nonfaulty processes emulate the ordinary Paxos algorithm despite the presence of f malicious processes. We have written a formal, machine-checked proof that the Byzantized algorithm implements the ordinary Paxos consensus algorithm under a suitable refinement mapping.",
isbn="978-3-642-24100-0"
}

@article{Delzanno_2014,
   title={Model Checking Paxos in Spin},
   volume={161},
   ISSN={2075-2180},
   DOI={10.4204/eptcs.161.13},
   journal={Electronic Proceedings in Theoretical Computer Science},
   publisher={Open Publishing Association},
   author={Delzanno, Giorgio and Tatarek, Michele and Traverso, Riccardo},
   year={2014},
   month={Aug},
   pages={131–146}
}

@inproceedings{uofu_conformance,
  title={Asynchronous Circuit Verification Using Trace Theory and CCS},
  author={Ganesh Gopalakrishnan},
  year={1995}
}

@INPROCEEDINGS{safety_inf_state,
  author={Emerson, E.A. and Namjoshi, K.S.},
  booktitle={Proceedings. Thirteenth Annual IEEE Symposium on Logic in Computer Science (Cat. No.98CB36226)}, 
  title={On model checking for non-deterministic infinite-state systems}, 
  year={1998},
  volume={},
  number={},
  pages={70-80},
  doi={10.1109/LICS.1998.705644}}

@article{liveness_inf_state,
title = {Liveness Checking as Safety Checking for Infinite State Spaces},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {149},
number = {1},
pages = {79-96},
year = {2006},
note = {Proceedings of the 7th International Workshop on Verification of Infinite-State Systems (INFINITY 2005)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2005.11.018},
url = {https://www.sciencedirect.com/science/article/pii/S1571066106000557},
author = {Viktor Schuppan and Armin Biere},
keywords = {liveness, safety, linear temporal logic, model checking, infinite state space},
abstract = {In previous work we have developed a syntactic reduction of repeated reachability to reachability for finite state systems. This may lead to simpler and more uniform proofs for model checking of liveness properties, help to find shortest counterexamples, and overcome limitations of closed-source model-checking tools. In this paper we show that a similar reduction can be applied to a number of infinite state systems, namely, (ω−)regular model checking, push-down systems, and timed automata.}
}

@article{liskov_substitution,
author = {Liskov, Barbara H. and Wing, Jeannette M.},
title = {A Behavioral Notion of Subtyping},
year = {1994},
issue_date = {Nov. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {6},
issn = {0164-0925},
doi = {10.1145/197320.197383},
abstract = {The use of hierarchy is an important component of object-oriented design. Hierarchy allows the use of type families, in which higher level supertypes capture the behavior that all of their subtypes have in common. For this methodology to be effective, it is necessary to have a clear understanding of how subtypes and supertypes are related. This paper takes the position that the relationship should ensure that any property proved about supertype objects also holds for its subtype objects. It presents two ways of defining the subtype relation, each of which meets this criterion, and each of which is easy for programmers to use. The subtype relation is based on the specifications of the sub- and supertypes; the paper presents a way of specifying types that makes it convenient to define the subtype relation. The paper also discusses the ramifications of this notion of subtyping on the design of type families.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {nov},
pages = {1811–1841},
numpages = {31},
keywords = {subtyping, Larch, formal specifications}
}

@inproceedings{Konnov,
author = {Konnov, Igor and Veith, Helmut and Widder, Josef},
year = {2012},
month = {07},
pages = {},
title = {Who is afraid of Model Checking Distributed Algorithms?}
}

@article{bitcoin,
author = {Nakamoto, Satoshi},
year = {2009},
month = {03},
pages = {},
title = {Bitcoin: A Peer-to-Peer Electronic Cash System},
journal = {Cryptography Mailing list at https://metzdowd.com}
}

@article{bateman_myCHIPs,
url={http://gotchoices.org/mychips/intro.html},
title={MyCHIPs Digital Money},
journal={MyCHIPs Digital Money at \url{https://gotchoices.org/mychips/intro.html} },
 author={Bateman, Kyle},
 year={2023},
 } 
 
@article{bateman_chip_value,
    url={https://chipcentral.net/wp-content/uploads/2023/01/chips\_note-1.pdf},
    title={Estimating the value of a CHIP}, journal={Estimating the value of a CHIP},
    author={Bateman, Kyle},
    year={2023},
 } 
 
@article{bateman_state_machines, 
    url={https://github.com/gotchoices/MyCHIPs/blob/master/doc/learn-protocol.md},
    title={MyCHIPs Protocol Description 1.3},
    journal={MyCHIPs Protocol Description 1.3},
    author={Bateman, Kyle},
    year={2023}
 } 
 
@book{dill_trace_theory,
      title={Trace theory for automatic hierarchical verification of speed-independent circuits},
      author={Dill, David L},
      volume={24},
      year={1989},
      publisher={MIT press Cambridge, MA}
}

@INPROCEEDINGS{ben_DC,  author={Ogles, Benjamin and Aldous, Peter and Mercer, Eric},  booktitle={2019 Formal Methods in Computer Aided Design (FMCAD)},   title={Proving Data Race Freedom in Task Parallel Programs Using a Weaker Partial Order},   year={2019},  volume={},  number={},  pages={55-63},  doi={10.23919/FMCAD.2019.8894270}}

@software{Storey_Extending_Model_Checking_2023,author = {Storey, Kyle and Mercer, Eric},month = {4},title = {{Extending Model Checking using Inductive Proofs in Distributed Digital Currency Protocols}},url = {https://github.com/byu-vv-lab/credit-lift-protocol-verification},version = {1.0.0},year = {2023}}


@article{reasoning_many_proc,
author = {German, Steven M. and Sistla, A. Prasad},
title = {Reasoning about Systems with Many Processes},
year = {1992},
issue_date = {July 1992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {3},
issn = {0004-5411},
doi = {10.1145/146637.146681},
abstract = {Methods are given for automatically verifying temporal properties of concurrent systems containing an arbitrary number of finite-state processes that communicate using CCS actions. TWo models of systems are considered. Systems in the first model consist of a unique control process and an arbitrary number of user processes with identical definitions. For this model, a decision procedure to check whether all the executions of a process satisfy a given specification is presented. This algorithm runs in time double exponential in the sizes of the control and the user process definitions. It is also proven that it is decidable whether all the fair executions of a process satisfy a given specification. The second model is a special case of the first. In this model, all the processes have identical definitions. For this model, an efficient decision procedure is presented that checks if every execution of a process satisfies a given temporal logic specification. This algorithm runs in time polynomial in the size of the process definition. It is shown how to verify certain global properties such as mutual exclusion and absence of deadlocks. Finally, it is shown how these decision procedures can be used to reason about certain systems with a communication network.},
journal = {J. ACM},
month = {jul},
pages = {675–735},
numpages = {61}
}

@inproceedings{clarke_base_ismc,
author = {Clarke, E. M. and Grumberg, O. and Browne, M. C.},
title = {Reasoning about Networks with Many Identical Finite-State Processes},
year = {1986},
isbn = {0897911989},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/10590.10611},
booktitle = {Proceedings of the Fifth Annual ACM Symposium on Principles of Distributed Computing},
pages = {240–248},
numpages = {9},
location = {Calgary, Alberta, Canada},
series = {PODC '86}
}

@article{component_language,
title = {Verification of component-based systems with recursive architectures},
journal = {Theoretical Computer Science},
volume = {940},
pages = {146-175},
year = {2023},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2022.10.022},
url = {https://www.sciencedirect.com/science/article/pii/S0304397522006181},
author = {Marius Bozga and Radu Iosif and Joseph Sifakis},
keywords = {Resource logic, Component-based distributed systems, Parameterized verification},
abstract = {We study a sound verification method for parametric component-based systems. The method uses a resource logic, a new formal specification language for distributed systems consisting of a finite yet unbounded number of components. The logic allows the description of architecture configurations coordinating instances of a finite number of types of components, by means of inductive definitions similar to the ones used to describe algebraic data types or recursive data structures. For parametric systems specified in this logic, we show that decision problems such as reaching deadlock or violating critical section are undecidable, in general. Despite this negative result, we provide for these decision problems practical semi-algorithms relying on the automatic synthesis of structural invariants allowing the proof of general safety properties. The invariants are defined using the WSκS fragment of the monadic second order logic, known to be decidable by a classical automata-logic connection, thus reducing a verification problem to checking satisfiability of a WSκS formula.}
}
@article{lowe_parameterized,
  author       = {Gavin Lowe},
  title        = {Parameterized verification of systems with component identities, using view abstraction},
  journal      = {Int. J. Softw. Tools Technol. Transf.},
  volume       = {24},
  number       = {2},
  pages        = {287--324},
  year         = {2022},
  doi          = {10.1007/s10009-022-00648-0},
  timestamp    = {Fri, 13 May 2022 19:53:01 +0200},
  biburl       = {https://dblp.org/rec/journals/sttt/Lowe22.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{view_abstraction,
author = {Abdulla, Parosh and Haziza, Fr\'{e}d\'{e}ric and Hol\'{\i}k, Luk\'{a}\v{s}},
title = {Parameterized Verification through View Abstraction},
year = {2016},
issue_date = {October   2016},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {18},
number = {5},
issn = {1433-2779},
doi = {10.1007/s10009-015-0406-x},
abstract = {We present a simple and efficient framework for automatic verification of systems with a parametric number of communicating processes. The processes may be organized in various topologies such as words, multisets, rings, or trees. Our method needs to inspect only a small number of processes in order to show correctness of the whole system. It relies on an abstraction function that views the system from the perspective of a fixed number of processes. The abstraction is used during the verification procedure in order to dynamically detect cut-off points beyond which the search of the state space need not continue. We show that the method is complete for a large class of well quasi-ordered systems including Petri nets. Our experimentation on a variety of benchmarks demonstrate that the method is highly efficient and that it works well even for classes of systems with undecidable verification problems. In particular, the method handles the fine-grained and full version of Szymanski's mutual exclusion protocol, whose correctness, to the best of our knowledge, has not been proven automatically by any other existing methods.},
journal = {Int. J. Softw. Tools Technol. Transf.},
month = {oct},
pages = {495–516},
numpages = {22},
keywords = {Parameterized systems, Small model properties, View abstraction, Safety}
}
@inproceedings{message_passing_conformance,
author = {Rajamani, Sriram K. and Rehof, Jakob},
title = {Conformance Checking for Models of Asynchronous Message Passing Software},
year = {2002},
isbn = {3540439978},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We propose a notion of conformance between a specification S and an implementation model I extracted from a message-passing program. In our framework, S and I are CCS processes, which soundly abstract the externallyv isible communication behavior of a message-passing program. We use the extracted models to check that programs do not get stuck, waiting to receive or trying to send messages in vain.We show that our definition of stuckness and conformance capture important correctness conditions of message-passing software. Our definition of conformance was motivated byt he need for modular reasoning over models, leading to the requirement that conformance preserve substi-tutabilitywith respect to stuck-freeness: If I conforms to S, and P is any environment such that P | S is stuck-free, then it follows that P | I is stuck-free. We present a simple algorithm for checking if I conforms to S, when I and S obeycert ain restrictions.},
booktitle = {Proceedings of the 14th International Conference on Computer Aided Verification},
pages = {166–179},
numpages = {14},
series = {CAV '02}
}


@inproceedings{conformance_example,
author = {Driscoll, Evan and Burton, Amanda and Reps, Thomas},
title = {Checking Conformance of a Producer and a Consumer},
year = {2011},
isbn = {9781450304436},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/2025113.2025132},
abstract = {This paper addresses the problem of identifying incompatibilities between two programs that operate in a producer/consumer relationship. It describes the techniques that are incorporated in a tool called PCCA (Producer-Consumer Conformance Analyzer), which attempts to (i) determine whether the consumer is prepared to accept all messages that the producer can emit, or (ii) find a counter-example: a message that the producer can emit and the consumer considers ill-formed.},
booktitle = {Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering},
pages = {113–123},
numpages = {11},
keywords = {language containment, visibly pushdown automata, producer-consumer compatibility},
location = {Szeged, Hungary},
series = {ESEC/FSE '11}
}

@article{timebank1,
title = {The Time Bank Implementation and Governance: Is PRINCE 2 Suitable?},
journal = {Procedia Technology},
volume = {16},
pages = {950-956},
year = {2014},
issn = {2212-0173},
doi = {https://doi.org/10.1016/j.protcy.2014.10.048},
url = {https://www.sciencedirect.com/science/article/pii/S2212017314002758},
author = {Lukas Valek},
keywords = {Time Bank, PRINCE 2, project management, time currency},
abstract = {This study aims to find out whether project management method PRINCE 2® is suitable to be used as a method how to implement and lead a Time Bank as a project. This paper compares previous researches done in time banking with the theory of PRINCE 2® framework. There are two phases of Time Bank life analyzed; the implementation (starting up) of a time bank and the governance (running). The preliminary analysis conducted shows that the project management concept of PRINCE 2® might be applied in implementation phase; in the governance phase, on the other side, it would probably generate more problems and costs, by burdening Time Bank existence, than positives.}
}

@article{timebank2,
  title={Learning to exchange time: Benefits and obstacles to time banking},
  author={Ozanne, Lucie K},
  year={2010},
  publisher={University of Canterbury. Management}
}